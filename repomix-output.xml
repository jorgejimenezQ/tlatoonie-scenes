This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .vscode/*, ./assets/*, **/*.json, **/*.svg, **/*.png
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    pages.yml
css/
  style.css
public/
  assets/
    d.js
src/
  action/
    action.js
  animation/
    animation.js
  asset/
    assets.js
  attack/
    Attack.js
  components/
    components.js
  entityManager/
    entityManager.js
  gameEngine/
    gameEngine.js
  scene/
    playerStates.js
    playScene.js
    scene.js
  systems/
    collision.js
  ui/
    buttons/
      entityList/
        entities.template.html
        entity.base.css
      button.js
    dock/
      dock.css
      dock.js
    print-json/
      print-json.js
    tabs/
      createTabs.js
      tabs-retro.css
      tabs.base.css
      tabs.js
      theme-crt.css
      theme-light.css
      theme-mac9.css
      theme-synthwave.css
      theme-win95.css
    entities.template.html
  utils/
    enums.js
    events.js
    file.js
    sprite.js
    spriteCacheGPU.js
    texture.js
    userInput.js
  counter.js
  editor.js
  main.js
.gitignore
index.html
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/attack/Attack.js">
import { EntityStates, PlayerAttacks } from '../utils/enums';

class Attack {
    /** @type {AttackComponent[]} */
    attackComponents = new Array();

    /**
     *
     * @param {PlayerAttacks} name The tag that identifies the attack.
     * @param {EntityStates} animation The name of the animation to run with this attack.
     */
    constructor(name, animation) {
        this.name = name;
        this.animation = animation;
    }
}

export { Attack };
</file>

<file path="src/entityManager/entityManager.js">
import { createComponent } from '../components/components';

class Entity {
    #componentMap = new Map();
    #isActive = true;
    #entityId = 0;
    #entityTag = '';

    constructor(id, tag) {
        this.#entityId = id;
        this.#entityTag = tag;
    }

    destroy() {
        this.#isActive = false;
    }

    isActive() {
        return this.#isActive;
    }

    getTag() {
        return this.#entityTag;
    }

    hasComponent(component) {
        return this.#componentMap.has(component);
    }

    addComponent(component, tag) {
        return this.#componentMap.set(tag, component);
    }

    /**
     * Retrieves a component from the entity's component map.
     * @param {string} component the type of component to retrieve
     * @returns {Object} the component if it exists, otherwise undefined
     */
    getComponent(component) {
        return this.#componentMap.get(component);
    }

    /**
     * Retrieves the tag associated with this entity.
     * @returns {string} The tag associated with this entity.
     */
    get tag() {
        return this.#entityTag;
    }
    /**
     * Retrieves the unique identifier for this entity.
     * @returns {number} The id of the entity.
     */
    get id() {
        return this.#entityId;
    }

    getComponents() {
        return this.#componentMap;
    }

    removeComponent(component) {
        this.#componentMap.delete(component);
    }
}

class EntityManager {
    #entityList = new Array();
    #entityListToAdd = new Array();
    #entityListMap = new Map();
    #totalEntities = 0;

    #removeDeadEntities() {}

    /**
     * Updates the entity manager by adding new entities to the live lists,
     * removing dead entities from the live lists, and removing empty tag buckets.
     * @returns {boolean} Whether any changes were made to the entity manager.
     */
    update() {
        let changed = false;
        if (this.#entityListToAdd.length != 0) changed = true;
        // 1) Move queued entities into live lists
        for (const entity of this.#entityListToAdd) {
            this.#entityList.push(entity);

            const tag = entity.getTag();
            if (!this.#entityListMap.has(tag)) this.#entityListMap.set(tag, []);
            this.#entityListMap.get(tag).push(entity);
        }
        this.#entityListToAdd.length = 0;

        // 2) Cull dead from the flat list
        this.#entityList = this.#entityList.filter((e) => e.isActive());

        // 3) Cull dead from each tag bucket (and drop empty buckets)
        for (const [tag, list] of this.#entityListMap) {
            const filtered = list.filter((e) => e.isActive());
            if (filtered.length) {
                this.#entityListMap.set(tag, filtered);
            } else {
                this.#entityListMap.delete(tag);
            }
        }

        return changed;
    }

    addEntity(tag) {
        // add to flat list
        let entity = new Entity(this.#totalEntities++, tag);
        this.#entityListToAdd.push(entity);

        return entity;
    }

    /**
     * Retrieves all entities in the entity manager.
     *
     * @returns {Entity[]} A list of all entities.
     */
    getAllEntities() {
        return this.#entityList;
    }

    getEntitiesWithTag(tag) {
        return this.#entityListMap.get(tag);
    }

    getEntitiesMap() {
        return this.#entityListMap;
    }
}

class EntityState {}

export { EntityManager, Entity };
</file>

<file path="src/scene/playerStates.js">
import { ComponentTypes, ActionLifeCycle, ActionEnums, EntityStates } from '../utils/enums';
import { Entity } from '../entityManager/entityManager';
import { Gravity, Transform, AnimationContainer, Attacks, State } from '../components/components';
import { Action } from '../action/action';
import { Attack } from '../attack/Attack';

const playerStateCallbacks = new Map();
const stateSet = new Set();

const inAir = {
    entry: (e) => {},
    exit: (e) => {},
    /**
     *
     * @param {Entity} e
     */
    update: (e) => {},
    handleAction: (e, action) => {
        console.log('inAir', action);
        if (action.name === ActionEnums.RIGHT) {
            const t = e.getComponent(ComponentTypes.CTransform);
            if (action.lifeCycle === ActionLifeCycle.END) {
                t.acceleration.x = 0;
                t.velocity.x = 0;
                return;
            }

            t.scale.x = Math.abs(t.scale.x);
        }
        if (action.name === ActionEnums.LEFT) {
            const t = e.getComponent(ComponentTypes.CTransform);
            if (action.lifeCycle === ActionLifeCycle.END) {
                t.acceleration.x = 0;
                t.velocity.x = 0;
                return;
            }

            t.scale.x = -1 * Math.abs(t.scale.x);
        }

        if (action.name === ActionEnums.ON_GROUND && action.lifeCycle === ActionLifeCycle.START) {
            // /** @type {AnimationContainer} */
            // const ca = e.getComponent(ComponentTypes.CAnimation);
            // ca.popAnimation().reset();
            setPlayerState(e, EntityStates.ON_GROUND);
        }
    },
};

const falling = {
    entry: (e) => {
        /** @type {Transform} */
        const ctr = e.getComponent(ComponentTypes.CTransform);
        /** @type {Gravity} */
        const cg = e.getComponent(ComponentTypes.CGravity);
        ctr.acceleration.y += cg.gravity.y;
    },
    exit: (e) => {
        return;
    },
    handleAction: (e, action) => {
        console.log('falling', action);
        inAir.handleAction(e, action);
    },
    update: () => {},
};

const jumping = {
    entry: (e) => {},
    exit: (e) => {},
    /**
     *
     * @param {Entity} e
     */
    update: (e) => {},
    handleAction: (e, action) => {
        console.log('jumping', action);
        if (action.name === ActionEnums.FALL && action.lifeCycle === ActionLifeCycle.START) {
            setPlayerState(e, EntityStates.FALLING);
        }
        inAir.handleAction(e, action);
    },
};

const onGround = {
    entry: (e) => {
        /** @type {Transform} */
        const t = e.getComponent(ComponentTypes.CTransform);
        const moving = Math.abs(t.acceleration.x) > 0 || Math.abs(t.velocity.x) > 0;

        if (moving) {
            setPlayerState(e, t.scale.x >= 0 ? EntityStates.WALKING_RIGHT : EntityStates.WALKING_LEFT);
        }
    },
    exit: (e) => {
        return;
    },
    handleAction: (e, action) => {
        if (action.name === ActionEnums.RIGHT && action.lifeCycle === ActionLifeCycle.START) {
            setPlayerState(e, EntityStates.WALKING_RIGHT);
        }
        if (action.name === ActionEnums.LEFT && action.lifeCycle === ActionLifeCycle.START) {
            setPlayerState(e, EntityStates.WALKING_LEFT);
        }
        if (action.name === ActionEnums.JUMP && action.lifeCycle === ActionLifeCycle.START) {
            /** @type {Transform} */
            const t = e.getComponent(ComponentTypes.CTransform);
            t.velocity.y = -t.vSpeed;
            setPlayerState(e, EntityStates.JUMPING);
        }
    },
    update: () => {},
};

const walkingRight = {
    entry: (e) => {
        /** @type {Transform} */
        const t = e.getComponent(ComponentTypes.CTransform);
        t.velocity.x = 0;
        t.scale.x = Math.abs(t.scale.x);
        t.acceleration.x = t.hSpeed;
    },
    exit: (e) => {},
    handleAction: (e, action) => {
        /** @type {Transform} */
        const t = e.getComponent(ComponentTypes.CTransform);
        /** @type {AnimationContainer} */
        const ca = e.getComponent(ComponentTypes.CAnimation);

        if (action.name === ActionEnums.RIGHT && action.lifeCycle === ActionLifeCycle.END) {
            t.acceleration.x = 0;
            t.velocity.x = 0;
            // ca.peekAnimation().stop();
            ca.popAnimation();
            setPlayerState(e, EntityStates.IDLE);
            return;
        }

        onGround.handleAction(e, action);
    },
    update: () => {},
};

const walkingLeft = {
    entry: (e) => {
        /** @type {Transform} */
        const t = e.getComponent(ComponentTypes.CTransform);
        t.velocity.x = 0;
        t.scale.x = -1 * Math.abs(t.scale.x);
        t.acceleration.x = -1 * t.hSpeed;
    },
    exit: (e) => {},
    handleAction: (e, action) => {
        /** @type {Transform} */
        const t = e.getComponent(ComponentTypes.CTransform);
        /** @type {AnimationContainer} */
        const ca = e.getComponent(ComponentTypes.CAnimation);
        if (action.name === ActionEnums.LEFT && action.lifeCycle === ActionLifeCycle.END) {
            t.acceleration.x = 0;
            t.velocity.x = 0;
            ca.popAnimation();
            setPlayerState(e, EntityStates.IDLE_LEFT);
            return;
        }
        onGround.handleAction(e, action);
    },
    update: () => {},
};

const idle = {
    entry: (e) => {
        /** @type {Transform} */
        const t = e.getComponent(ComponentTypes.CTransform);
        t.scale.x = Math.abs(t.scale.x);
    },
    exit: (e) => {
        return;
    },
    handleAction: (e, action) => {
        onGround.handleAction(e, action);

        if (action.name === ActionEnums.ATTACK && action.lifeCycle == ActionLifeCycle.START) {
            setPlayerState(e, EntityStates.ATTACKING);
        }
    },
    update: (entity) => {},
};

const attacking = {
    entry: (e) => {
        /** @type {AnimationContainer} */
        const ca = e.getComponent(ComponentTypes.CAnimation);
        /** @type {Attacks} */
        const cAtt = e.getComponent(ComponentTypes.CAttacks);
        /** @type {State} */
        const cst = e.getComponent(ComponentTypes.CState);
        /** @type {Attack} */
        const attack = cAtt.getSelectedAttack();
        ca.peekAnimation().onCompleteState = cst.previous;
        setPlayerState(e, attack.animation);
    },
    exit: (e) => {},
    handleAction: (e, action) => {},
    update: () => {},
};

const idleLeft = {
    entry: (e) => {
        /** @type {Transform} */
        const t = e.getComponent(ComponentTypes.CTransform);
        t.scale.x = -1 * Math.abs(t.scale.x);
    },
    exit: (e) => {
        return;
    },
    handleAction: (e, action) => {
        onGround.handleAction(e, action);
        if (action.name === ActionEnums.ATTACK && action.lifeCycle == ActionLifeCycle.START) {
            setPlayerState(e, EntityStates.ATTACKING);
        }
    },
    update: (entity) => {},
};

const empty = {
    entry: (e) => {},
    exit: (e) => {},
    handleAction: (e, action) => {},
    update: (entity) => {},
};

playerStateCallbacks.set(EntityStates.JUMPING, jumping);
playerStateCallbacks.set(EntityStates.WALKING_RIGHT, walkingRight);
playerStateCallbacks.set(EntityStates.WALKING_LEFT, walkingLeft);
playerStateCallbacks.set(EntityStates.IDLE, idle);
playerStateCallbacks.set(EntityStates.ON_GROUND, onGround);
playerStateCallbacks.set(EntityStates.FALLING, falling);
playerStateCallbacks.set(EntityStates.IDLE_LEFT, idleLeft);
playerStateCallbacks.set(EntityStates.ATTACKING, attacking);
playerStateCallbacks.set(EntityStates.ATTACKING_ONE, empty);
playerStateCallbacks.set(EntityStates.ATTACKING_TWO, empty);

function setPlayerState(entity, next) {
    const cState = entity.getComponent(ComponentTypes.CState);
    if (!cState || cState.current === next) return;
    const from = playerStateCallbacks.get(cState.current);
    const to = playerStateCallbacks.get(next);

    // exit old
    from?.exit?.(entity);
    // switch
    cState.current = next;
    // enter new
    to?.entry?.(entity);
}

export default playerStateCallbacks;
</file>

<file path="src/scene/playScene.js">
import { Scene } from './scene';
import { Vector } from 'vecti';
import { EntityManager, Entity } from '../entityManager/entityManager';
import {
    ActionEnums,
    ActionKeys,
    ActionLifeCycle,
    ComponentTypes,
    CustomEventEnums,
    EntityFlags,
    EntityTypes,
    PlayerAttacks,
    EntityStates,
    ScalePolicies,
    SceneTags,
} from '../utils/enums';
import {
    createComponent,
    Transform as TransformType,
    Flags as FlagsType,
    Collision as CollisionType,
    State as StateType,
    Gravity as GravityType,
    Traits as TraitsType,
    AnimationContainer,
    Attacks as AttacksType,
    AnimationStackEntry,
} from '../components/components';
import { Animation } from '../animation/animation';
import { getScaledSpriteSize } from '../utils/sprite';
import playerStateCallbacks from './playerStates';
import { CollisionSystem } from '../systems/collision';
import { Action } from '../action/action';
import { Attack } from '../attack/Attack';

/**
 * TODO: Refactor entity configs out into JSON files
 *
 * GOAL
 * - Move hardcoded entity setup (player, tiles, NPCs, etc.) into data-driven JSON.
 * - Keep code generic: read JSON â†’ build components â†’ spawn entities.
 *
 * FILE LAYOUT (proposed)
 * - /assets/config.json                      â†’ root index (lists packs/files, version)
 * - /assets/entities/player.json             â†’ a single entity archetype
 * - /assets/entities/tile.json               â†’ tile archetype(s)
 * - /assets/entities/*.json                  â†’ other archetypes
 * - /assets/animations/*.json                â†’ animation clips (or inside entity)
 * - /assets/spritesheets/*.json              â†’ atlas metadata (if not already)
 *
 * JSON SCHEMA (entity) â€“ v1
 * {
 *   "version": 1,
 *   "entityType": "PLAYER",                // maps to EntityTypes.*
 *   "tag": "PLAYER",
 *   "spawn": { "grid": [1,1] },            // or "world": [x,y]
 *   "components": {
 *     "CTransform": {
 *       "position": { "x": 0, "y": 0 },   // CENTER in world space (source of truth)
 *       "velocity": { "x": 5, "y": 3 },
 *       "scale":    { "x": 1, "y": 1 },
 *       "angle": 0
 *     },
 *     "CSprite": {
 *       "sheetId": "knight",               // must exist in assets.spriteSheets
 *       "frame":   "idle_000"
 *     },
 *     "CSpriteDimensions": {
 *       "logical": { "x": 64, "y": 64 },   // original (incl. padding)
 *       "trimmed": { "x": 16, "y": 16 }    // opaque area; optional, infer from atlas if missing
 *     },
 *     "CBoundingBox": {
 *       "rectangle": { "x": 15, "y": 34 }, // unscaled logical bbox
 *       "offset":    { "x": 0,  "y": 0 }   // logical units; scaled at runtime
 *     },
 *     "CAnimation": {
 *       "clip": "idle",                    // default clip name
 *       "clips": ["idle","walk","jump"],   // optional preloaded pool for this entity
 *       "fps": 12,                         // default if clip lacks fps
 *       "loop": true
 *     },
 *     "CInput": {},
 *     "CState": { "current": "IDLE" },
 *     "CPhysics": {
 *       "horizontalSpeed": 5,
 *       "jumpSpeed": 15,
 *       "maxSpeed": 20,
 *       "gravity": 1
 *     }
 *   }
 * }
 *
 */

//Player *1 1 64 64* 5 15 20 1 Buster
/**
 * Play_Scene
 *
 * @description Scene for playing the game
 *
 *
 */
class PlayScene extends Scene {
    /*
     * TODO (anchors): Use CENTER as the single source of truth in CTransform.
     *
     * - Physics & interpolation operate on center (world space).
     * - Rendering/UI need top-left â†’ derive it from center + scaled logical size (+ scaled offsets).
     * - Do NOT store both center and top-left; compute one from the other to avoid drift.
     *
     * Helpers:
     * edit the current centeredBoundingRect method
     *
     * Tiles placed by top-left? Convert once at spawn:
     *   transform.position = topLeftToCenter(tileTopLeft, scaledTileSize);
     *
     */

    //TODO: refactor configs out into json files (entity)
    #playerConfig = {
        gridPos: new Vector(1, 5),
        boundingBox: new Vector(8, 34),
        boundingBoxOffset: new Vector(0, 0),
        horizontalSpeed: 200,
        verticalSpeed: 200,
        jumpSpeed: 15,
        maxSpeed: 20,
        gravity: 0.001,
        spriteRectangle: new Vector(16, 16),
        animation: EntityStates.IDLE,
        sprite: 'knight',
        initialPosition: new Vector(0, 0),
        initialVelocity: new Vector(5, 3),
        size: new Vector(64, 64),
        initialScale: new Vector(26, 34),
    };

    #entityConfig = {
        [EntityTypes.PLAYER]: this.#playerConfig,
        [EntityTypes.TILE]: {
            gridPos: new Vector(1, 1),
            boundingBox: null,
            boundingBoxOffset: new Vector(0, 0),
            horizontalSpeed: null,
            jumpSpeed: 15,
            maxSpeed: 20,
            gravity: 1,
            // spriteRectangle: new Vector(16, 16),
            // animation: 'jump',
            // sprite: 'knight',
            // initialPosition: new Vector(0, 0),
            // initialVelocity: new Vector(5, 3),
            // size: new Vector(64, 64),
            // initialScale: new Vector(26, 34),
        },
    };

    #actionsQueue = [];

    #playerAnimationMap = new Map();

    #simTime = 0;

    #mapConfig = {
        tileSize: new Vector(64, 64),
        numTiles: 0,
    };

    #player = new Entity();
    #drawTextures = true;
    #drawCollisions = true;
    #drawGrid = true;
    #drawHoverTile = true;
    #gridText;
    #gridTiles = new Map();
    #pointerX = null;
    #pointerY = null;
    #camera = new Vector(0, 0);
    #fallingThreshold = 1; // in seconds

    drawTexture = true;

    #gridPattern = null; // CanvasPattern
    #gridPatternCanvas = null; // OffscreenCanvas | HTMLCanvasElement (debug/cleanup)
    #gridPatternTile = { x: 0, y: 0 }; // the tile size used to build the pattern
    #gridPatternDPR = 0; // so we can rebuild when DPR changes
    #gridMajorEvery = 1; // draw a stronger line every N cells

    collisions = new CollisionSystem();

    constructor(gameEngine) {
        super(gameEngine, SceneTags.PLAY);

        this.registerAction(ActionKeys.p, ActionEnums.PAUSE);
        this.registerAction(ActionKeys.l, ActionEnums.ATTACK);
        this.registerAction(ActionKeys.escape, ActionEnums.QUIT);
        this.registerAction(ActionKeys.num_0, ActionEnums.TOGGLE_TEXTURE);
        this.registerAction(ActionKeys.num_1, ActionEnums.TOGGLE_COLLISION);
        this.registerAction(ActionKeys.num_2, ActionEnums.TOGGLE_GRID);
        this.registerAction(ActionKeys.space, ActionEnums.JUMP);
        this.registerAction(ActionKeys.a, ActionEnums.LEFT);
        this.registerAction(ActionKeys.d, ActionEnums.RIGHT);
        this.registerAction(ActionKeys.s, ActionEnums.DOWN);
        this.registerAction(ActionKeys.w, ActionEnums.JUMP);
        this.registerAction(ActionKeys.pointerDown, ActionEnums.CLICK);
        this.registerAction(ActionKeys.pointerMove, ActionEnums.POINTER_POSITION);

        this.#mapConfig.numTiles = new Vector(
            this.gameEngine.logicalWidth / this.#mapConfig.tileSize.x,
            this.gameEngine.logicalHeight / this.#mapConfig.tileSize.y
        );

        // create a ready animation for each
        console.groupCollapsed('-------------------------------------\nAnimation pool');
        console.log('create an animation pool for the player to re-use');
        for (let anim of gameEngine.getAnimations().keys()) {
            this.#playerAnimationMap.set(anim, new Animation(anim, gameEngine.getAnimation(anim), gameEngine));
        }

        console.log(this.#playerAnimationMap);
        console.groupEnd();
        this.#loadLevel();
    }

    #loadLevel() {
        this.entityManager = new EntityManager();
        // TODO: Use configuration files to create the components and entities

        // sprite dimensions
        let spriteDimensions = this.gameEngine.getSpriteDimensions(this.#playerConfig.sprite);
        let trimmedRect = this.gameEngine.getSpriteTrimmedRect(this.#playerConfig.sprite);

        // initial transformations
        let pos = this.#playerConfig.initialPosition;
        let vel = new Vector(0, 0);
        let scale = new Vector(
            this.#playerConfig.size.x / trimmedRect.width,
            this.#playerConfig.size.y / trimmedRect.height
        );
        let angle = 0;
        let hSpeed = this.#playerConfig.horizontalSpeed;
        let vSpeed = this.#playerConfig.verticalSpeed;

        let attacks = [];
        for (const [name, animation] of this.gameEngine.levelConfig.playerConfig.attacks) {
            attacks.push(new Attack(name, animation.animationId));
        }

        console.log(attacks);
        /** @type {Animation} */
        const animation = this.#playerAnimationMap.get(this.#stateToAnimation(this.#playerConfig.animation));
        console.log('The initial animation', animation);

        this.#player = this.#spawnEntity(
            {
                [ComponentTypes.CAnimation]: [animation.repeats],
                [ComponentTypes.CSpriteDimensions]: [
                    new Vector(spriteDimensions.w, spriteDimensions.h),
                    new Vector(trimmedRect.width, trimmedRect.height),
                ],
                [ComponentTypes.CTransform]: [pos, vel, scale, angle, hSpeed, vSpeed],
                [ComponentTypes.CBoundingBox]: [
                    new Vector(trimmedRect.width, trimmedRect.height),
                    this.#playerConfig.boundingBoxOffset,
                ],
                [ComponentTypes.CState]: [EntityStates.IDLE],
                [ComponentTypes.CFlags]: [
                    EntityFlags.PLAYER |
                        EntityFlags.INTERACTIVE |
                        EntityFlags.COLLIDES |
                        EntityFlags.ANIMATED |
                        EntityFlags.CAN_FALL,
                ],
                [ComponentTypes.CCollision]: [],
                [ComponentTypes.CGravity]: [new Vector(0, 600)],
                [ComponentTypes.CAttacks]: [PlayerAttacks.ATTACK_ONE],
            },
            EntityTypes.PLAYER,
            this.#playerConfig.gridPos.x,
            this.#playerConfig.gridPos.y
        );

        /** @type {AttacksType} */
        const cAttacks = this.#player.getComponent(ComponentTypes.CAttacks);
        /** @type {GravityType} */
        const cg = this.#player.getComponent(ComponentTypes.CGravity);

        attacks.forEach((e) => cAttacks.addAttack(e));
        cg.timeBeforeFalling = 0.5;

        /** @type {AnimationContainer} */
        const cAnim = this.#player.getComponent(ComponentTypes.CAnimation);
        // Add a pointer to an animation pool
        cAnim.animationPool = this.#playerAnimationMap;
        cAnim.pushAnimation(animation);
    }

    /**
     * @returns {Map<string, Action>} - A Map of action name to Action object.
     */
    getActions() {
        return this.actionMap;
    }

    #spawnPlayer() {}
    #spawnBullet(entity) {}

    /**********************************************************************
     *  Systems
     *********************************************************************/
    /* Move the entity based on its current state */
    #sMovement(entity, dt) {
        /** @type {TransformType} */
        const ctr = entity.getComponent(ComponentTypes.CTransform);

        ctr.velocity = ctr.velocity.add(ctr.acceleration); // Acceleration => Velocity
        ctr.position = ctr.position.add(ctr.velocity.multiply(dt)); // Velocity => Position
        ctr.acceleration = ctr.acceleration.multiply(0); // Clear per-Frame forces
    }

    /**
     *
     * @param {Entity} entity The entity we are applying the force on.
     * @param {Vector} force The force we are applying to the entity.
     */
    #sApplyForce(dt, entity, force) {
        /** @type {Transform} */
        let ctr = entity.getComponent(ComponentTypes.CTransform);
        ctr.acceleration = ctr.acceleration.add(force);
        ctr.acceleration = ctr.acceleration.multiply(dt);
    }

    #sLifespan(entity) {}
    #sAnimation(entity) {
        // TODO: handle non repeating animations and state changes
        /** @type {StateType} */
        const cst = entity.getComponent(ComponentTypes.CState);
        /** @type {AnimationContainer} */
        const ca = entity.getComponent(ComponentTypes.CAnimation);
        /** @type {AnimationStackEntry} */
        let current = ca.peekAnimation();

        // Ensure there is a base animation.
        if (!current) {
            const key = this.#stateToAnimation(cst.current);
            const base = ca.animationPool.get(key);
            ca.pushAnimation(base);
            current = ca.peekAnimation();
        }

        if (current.hasEnded()) {
            ca.popAnimation();
            cst.current = ca.peekAnimation().onCompleteState;
        }
        const nextAnim = this.#playerAnimationMap.get(this.#stateToAnimation(cst.current));
        current = ca.peekAnimation();
        if (current.name !== nextAnim.name) {
            ca.pushAnimation(nextAnim, cst.previous);
        }
    }

    fixedUpdate(dt) {
        if (this.paused) return;

        for (let entity of this.entityManager.getAllEntities()) {
            /** @type {FlagsType} */
            const cf = entity.getComponent(ComponentTypes.CFlags);
            if (cf.has(EntityFlags.DECORATION)) continue;
            /** @type {StateType} */
            const cs = entity.getComponent(ComponentTypes.CState);
            /** @type { BoundingBox} */
            const bBox = entity.getComponent(ComponentTypes.CBoundingBox);
            /** @type { Transform } */
            const tr = entity.getComponent(ComponentTypes.CTransform);

            // Update the animation for the entity
            if (cf.has(EntityFlags.ANIMATED)) this.#sAnimation(entity);

            // Run the actions
            // TODO: Actions for non-player entities.
            if (cf.has(EntityFlags.PLAYER)) this.sActions();

            if (cs.current == EntityStates.JUMPING && cf.has(EntityFlags.CAN_FALL)) {
                /** @type {GravityType} */
                const cg = entity.getComponent(ComponentTypes.CGravity);
                this.#sApplyForce(dt, entity, cg.gravity);
                // Has the entity reached the apex from velocity, bring it down
                if (tr.velocity.y >= 0) {
                    console.log('******************************************************************************');
                    this.actionEnqueue(new Action(ActionEnums.FALL, ActionLifeCycle.START));
                }
            }

            // Run collision tests
            if (!cf.has(EntityFlags.STATIC) && cf.has(EntityFlags.COLLIDES)) {
                this.#sMovement(entity, dt);
                this.sCollision(entity);

                // update the position of the bounding box
                bBox.position = tr.position;
            }
        }

        let changed = this.entityManager.update();
        if (changed) {
            this.gameEngine.dispatchEvent(
                new CustomEvent(CustomEventEnums.ENTITIES.UPDATED, {
                    detail: {
                        count: this.entityManager.getAllEntities().length,
                        entities: this.entityManager.getAllEntities(),
                    },
                })
            );
        }
    }

    onFrameEnd(elapsedTime, numUpdateSteps) {
        for (let entity of this.entityManager.getAllEntities()) {
            /** @type {FlagsType} */
            const cf = entity.getComponent(ComponentTypes.CFlags);
            if (cf.has(EntityFlags.ANIMATED)) {
                /** @type {AnimationContainer} */
                const ca = entity.getComponent(ComponentTypes.CAnimation);
                ca.peekAnimation().update(elapsedTime);
            }
        }
    }

    async sRender(alpha) {
        if (this.paused) return;
        if (this.#drawGrid) this.#renderGridPattern(this.gameEngine.ctx);

        for (let entity of this.entityManager.getAllEntities()) {
            /** @type {Transform} */
            let tr = entity.getComponent(ComponentTypes.CTransform);
            /** @type {FlagsType} */
            let bBox = entity.getComponent(ComponentTypes.CBoundingBox);

            // show the sprite
            if (this.drawTexture && entity.getComponent(ComponentTypes.CAnimation)) {
                /** @type {AnimationContainer} */
                const ca = entity.getComponent(ComponentTypes.CAnimation);
                let { sheetId, frame } = ca.peekAnimation().getCurrentFrame();
                if (!tr.scale) {
                    tr.scale = new Vector(1, 1);
                }

                // TODO: Rendering stalls risk. sRender awaits drawSprite inside the frame loop, serializing draws and inviting jank. Batch draws or ensure drawSprite is synchronous after assets are loaded.
                await this.gameEngine.drawSprite(sheetId, frame, tr.position, tr.scale);
            } else if (this.drawTexture) {
                let cSprite = entity.getComponent(ComponentTypes.CSprite);
                if (!tr.scale) {
                    tr.scale = new Vector(1, 1);
                }
                await this.gameEngine.drawSprite(cSprite.sheetId, cSprite.frame, tr.position, tr.scale);
            }

            // show the center of the bounding box
            if (this.#drawCollisions) {
                // draw based on entity position
                let rectCentered = Vector.of([tr.position.x, tr.position.y]);
                rectCentered = rectCentered.subtract(bBox.halfSize);
                this.gameEngine.drawRect(rectCentered, bBox.size, 'rgba(205, 29, 41, 1)');
                this.gameEngine.drawCircleFilled(tr.position, 2, 'rgba(89, 255, 252, 1)');
                // draw based on entity's bounding box position
            }
        }

        if (this.#drawHoverTile && this.#pointerX && this.#pointerY) {
            let tile = this.#getTileUnderMouse();

            this.gameEngine.drawRect(
                new Vector(tile.x * this.#mapConfig.tileSize.x, tile.y * this.#mapConfig.tileSize.y),
                this.#mapConfig.tileSize,
                'rgba(145, 0, 0, 0.5)',
                'rgba(243, 157, 95, 0.57)'
            );
        }

        // this.gameEngine.drawCircleFilled(this.#gridToWorld(1, 4), 4, 'rgba(255, 0, 217, 1)');
        // this.gameEngine.drawCircleFilled(this.#gridToWorldCentered(1, 4), 4, 'rgba(255, 0, 217, 1)');
    }

    /**
     * Check for collisions between the given entity and all other entities.
     * If a collision is found, the entity's position will be adjusted to avoid the collision.
     * @param {Entity} entity - The entity to check for collisions.
     */
    sCollision(entity) {
        /** @type {Transform} */
        const tr = entity.getComponent(ComponentTypes.CTransform);
        /** @type {CollisionType} */
        const cc = entity.getComponent(ComponentTypes.CCollision);
        /** @type {BoundingBox} */
        const bb = entity.getComponent(ComponentTypes.CBoundingBox);

        const prevOverlap = { ...cc.prevOverlap };
        for (let other of this.entityManager.getAllEntities()) {
            // Guards
            if (entity.id === other.id) continue;
            if (!other.getComponent(ComponentTypes.CFlags).has(EntityFlags.COLLIDES)) continue;
            if (!other.getComponent(ComponentTypes.CBoundingBox)) continue;
            /** @type {Transform} */
            const otherTr = other.getComponent(ComponentTypes.CTransform);
            const result = this.collisions.calculateOverlap(entity, other);
            // "Cache" results
            cc.prevOverlap = { ...result };
            cc.prevOverlap.other = other;

            if (!result.overlapping) continue;

            // ðŸ¤–
            // 1) separate along MTV
            tr.position.x += result.mtv.x;
            tr.position.y += result.mtv.y;

            // 2) kill velocity on the resolved axis (prevents jitter)
            if (result.axis === 'x') {
                tr.velocity.x = 0;
            } else if (tr.position.y > otherTr.position.y) {
                console.log('hit top');
                this.actionEnqueue(new Action(ActionEnums.FALL, ActionLifeCycle.START));
            } else {
                tr.velocity.y = 0;
                this.actionEnqueue(new Action(ActionEnums.ON_GROUND, ActionLifeCycle.START));
            }

            // 3) keep bbox center in sync
            bb.position.x = tr.position.x;
            bb.position.y = tr.position.y;
        }
    }

    /**
     * Process all queued actions.
     * Actions are processed in the order they were received, and are processed until the queue is empty.
     * This function is responsible for updating the player's state based on the actions it receives.
     */
    sActions() {
        // Nothing to do.
        if (this.#actionsQueue.length == 0) return;

        // The player's current state
        /** @type {StateType} */
        let cState = this.#player.getComponent(ComponentTypes.CState);
        let state_ = playerStateCallbacks.get(cState.current);

        let action = this.actionsDequeue();
        while (action) {
            state_ = playerStateCallbacks.get(cState.current);
            state_.handleAction(this.#player, action);
            action = this.actionsDequeue();
        }
    }

    /**
     * Processes an immediate action.
     * Immediate actions are processed immediately, and are not queued.
     * This function is used to process actions that are not related to the player's state, such as mouse movements.
     *
     * @param {Action} action - The action to process.
     */
    sDoActionImm(action) {
        switch (action.name) {
            case ActionEnums.POINTER_POSITION:
                this.#pointerX = action.payload.x;
                this.#pointerY = action.payload.y;
                break;
            case ActionEnums.CLICK:
                this.#pointerX = action.payload.x;
                this.#pointerY = action.payload.y;
                // get grid coords
                const coords = this.#getTileUnderMouse();
                // console.log(coords, { x: this.#pointerX, y: this.#pointerY });
                break;
            default:
                break;
        }
    }

    sApplyGravity() {}

    onEnd() {
        console.log('end');
    }
    changePlayerStateTo(state) {}

    setPaused(isPaused) {
        console.log('setPaused', isPaused);
        this.paused = isPaused;
    }

    /**
     * Spawns an entity with no animation at the given grid coordinates with the given components.
     * @param {Component[]} components - A map of component type to component arguments.
     * @param {EntityTypes} type - The type of entity to spawn.
     * @param {number} gridX - The x coordinate in the grid.
     * @param {number} gridY - The y coordinate in the grid.
     * @param {EntityFlags} flags - The flags for the entity.
     * @param {string} sheetId - The id of the sprite sheet to use.
     * @param {string} frame - The id of the frame to use.
     * @param {boolean} isStatic - Whether the entity is static.
     * @returns {Entity} The entity that was spawned.
     *
     */
    placeSpriteEntityGrid(type, x = 0, y = 0, flags = [], traits = [], sheetId, frame) {
        let dims = this.gameEngine.getSpriteDimensions(sheetId);
        dims = new Vector(dims.w, dims.h);
        let trimmedRect = this.gameEngine.getSpriteTrimmedRect(sheetId);
        let hasTrimmedRect = trimmedRect != null;
        if (trimmedRect) trimmedRect = new Vector(trimmedRect.width, trimmedRect.height);
        else trimmedRect = new Vector(1, 1);

        let scale = new Vector(this.#mapConfig.tileSize.x / dims.x, this.#mapConfig.tileSize.y / dims.y);
        let pos = new Vector(x, y);
        let gridPos = this.#worldToGrid(new Vector(x, y));

        let components = {
            [ComponentTypes.CSprite]: [sheetId, frame],
            [ComponentTypes.CSpriteDimensions]: [dims, trimmedRect],
            [ComponentTypes.CTransform]: [pos, new Vector(0, 0), scale, 0],
            [ComponentTypes.CBoundingBox]: [hasTrimmedRect ? trimmedRect : dims, new Vector(0, 0)],
            [ComponentTypes.CFlags]: [],
            [ComponentTypes.CTraits]: [],
            [ComponentTypes.CState]: [EntityStates.IDLE],
        };

        let entity = this.#spawnEntity(components, type, gridPos.x, gridPos.y);

        if (flags.length > 0) {
            /** @type { FlagsType} */
            let cf = entity.getComponent(ComponentTypes.CFlags);
            for (let i = 0; i < flags.length; i++) {
                cf.add(flags[i]);
            }
        }

        if (traits.length > 0) {
            /** @type {TraitsType} */
            let cTraits = entity.getComponent(ComponentTypes.CTraits);
            for (let i = 0; i < traits.length; i++) {
                cTraits.add(traits[i]);
            }
        }
    }

    /**
     * Adds an action to the end of the action queue.
     * @param {Action} action - The action to add to the queue.
     */
    actionEnqueue(action) {
        this.#actionsQueue.push(action);
    }

    /**
     * Removes and returns the first action from the action queue.
     * If the queue is empty, returns null.
     * @returns {Action|null} The first action from the queue, or null if the queue is empty.
     */
    actionsDequeue() {
        let action = this.#actionsQueue.shift();
        if (action) return action;
        return null;
    }

    /**
     * Gets the tile coordinates of the given entity.
     * @param {Entity} e - The entity to get the tile coordinates of.
     * @returns {Vector} The tile coordinates of the entity.
     */
    getEntityTile(e) {
        /** @type {Transform} */
        const tr = e.getComponent(ComponentTypes.CTransform);
        return this.#worldToGrid(tr.position);
    }

    /****************************************************************************
     * HELPER FUNCTIONS
     ***************************************************************************/

    #isOverlapping() {}
    /**
     *
     * @param {number} gridX the x coordinate in the grid
     * @param {number} gridY the y coordinate in the grid
     * @returns {Vector} The in game world coordinated for the grid
     */
    #gridToWorld(gridX, gridY) {
        let worldX = gridX * this.#mapConfig.tileSize.x;
        let worldY = gridY * this.#mapConfig.tileSize.y;
        return new Vector(worldX, worldY);
    }

    /**
     *
     * @param {number} gridX the x coordinate in the grid
     * @param {number} gridY the y coordinate in the grid
     * @returns
     */
    #gridToWorldCentered(gridX, gridY) {
        let worldX = gridX * this.#mapConfig.tileSize.x;
        let worldY = gridY * this.#mapConfig.tileSize.y;
        return new Vector(worldX + this.#mapConfig.tileSize.x / 2, worldY + this.#mapConfig.tileSize.y / 2);
    }

    #getTileUnderMouse() {
        let gridX, gridY;
        if (this.#pointerX > 0) {
            gridX = (this.#pointerX / this.gameEngine.logicalWidth) * this.#mapConfig.numTiles.x;
        } else {
            gridX = 0;
        }

        if (this.#pointerY > 0) {
            gridY = (this.#pointerY / this.gameEngine.logicalHeight) * this.#mapConfig.numTiles.y;
        } else {
            gridY = 0;
        }

        gridX = Math.floor(gridX);
        gridY = Math.floor(gridY);
        return this.#worldToGrid(new Vector(this.#pointerX, this.#pointerY));
    }

    /** @param {Vector} worldPos */
    #worldToGrid(worldPos) {
        let gridX, gridY;
        if (worldPos.x > 0) {
            gridX = (worldPos.x / this.gameEngine.logicalWidth) * this.#mapConfig.numTiles.x;
        } else {
            gridX = 0;
        }

        if (worldPos.y > 0) {
            gridY = (worldPos.y / this.gameEngine.logicalHeight) * this.#mapConfig.numTiles.y;
        } else {
            gridY = 0;
        }

        gridX = Math.floor(gridX);
        gridY = Math.floor(gridY);
        return new Vector(gridX, gridY);
    }

    #scaleBoundingRect(entity) {
        /** @type { Transform } */
        let transform = entity.getComponent(ComponentTypes.CTransform);
        // / Get the bounding box
        /** @type { BoundingBox } */
        let cBoundingBox = entity.getComponent(ComponentTypes.CBoundingBox);
        let bBoxRect = cBoundingBox.rectangle;

        // Scale the bounding box
        let scaledRect = getScaledSpriteSize(bBoxRect, transform.scale, ScalePolicies.UNIFORM_Y, null);
        let halfSize = scaledRect.divide(2);

        // Find the center and top left of the sprite
        let center = new Vector(
            transform.position.x - halfSize.x + scaledRect.x / 2,
            transform.position.y - halfSize.y + scaledRect.y / 2
        );

        // The collision box is offset from the sprite
        // topLeft = topLeft.add(cBoundingBox.offset);

        // center = topLeft.add(halfSize);
        return { scaledRect, position: center };
    }

    #centerToTopLeft(bBox) {
        let halfSize = bBox.halfSize;
        return bBox.position.subtract(halfSize);
    }

    #renderGridPattern(ctx) {
        this.#ensureGridPattern();
        if (!this.#gridPattern) return;
        const w = Math.max(0, this.gameEngine.logicalWidth | 0);
        const h = Math.max(0, this.gameEngine.logicalHeight | 0);
        const tsX = this.#mapConfig.tileSize.x | 0;
        const tsY = this.#mapConfig.tileSize.y | 0;

        // Guard: bail if anything is invalid
        if (!isFinite(w) || !isFinite(h) || tsX < 2 || tsY < 1) return;

        // Camera/world offset (update when you add a camera)
        const camX = this.#camera.x,
            camY = this.#camera.y;

        // Align to world grid
        const offX = -(camX % tsX);
        const offY = -(camY % tsY);

        ctx.save();
        ctx.translate(offX | 0, offY | 0); // integer translate keeps 0.5 lines crisp
        ctx.fillStyle = this.#gridPattern;

        // Bleed 1 tile so seams never show at edges
        ctx.fillRect(-tsX, -tsY, w + tsX * 2, h + tsY * 2);

        // DEBUG ONE-FRAME OUTLINE: uncomment to verify we are drawing
        ctx.strokeStyle = 'magenta';
        ctx.lineWidth = 1;
        ctx.strokeRect(0.5, 0.5, 64, 64);
        ctx.restore();

        // ===== Optional: major lines and sparse labels =====
        const majorEvery = this.#gridMajorEvery | 0;
        if (majorEvery > 0) {
            const startCol = Math.floor(camX / tsX);
            const startRow = Math.floor(camY / tsY);

            // Count how many lines we actually need on-screen (+2 for bleed)
            const cols = Math.ceil((w - offX) / tsX) + 2;
            const rows = Math.ceil((h - offY) / tsY) + 2;

            const major = new Path2D();
            // Vertical majors
            for (let i = 0; i <= cols; i++) {
                const col = startCol + i;
                if (col % majorEvery !== 0) continue;
                const x = Math.round(offX + i * tsX) + 0.5;
                major.moveTo(x, 0);
                major.lineTo(x, h);
            }

            // Horizontal majors
            for (let j = 0; j <= rows; j++) {
                const row = startRow + j;
                if (row % majorEvery !== 0) continue;
                const y = Math.round(offY + j * tsY) + 0.5;
                major.moveTo(0, y);
                major.lineTo(w, y);
            }

            ctx.save();
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
            ctx.stroke(major);

            // Sparse labels at major intersections
            ctx.font = '10px ui-monospace, SFMono-Regular, Menlo, monospace';
            ctx.fillStyle = 'rgba(28, 16, 16, 0.87)';
            for (let i = 0; i <= cols; i += majorEvery) {
                const col = startCol + i;
                const x = Math.round(offX + i * tsX) + 4;
                for (let j = 0; j <= rows; j += majorEvery) {
                    const row = startRow + j;
                    const y = Math.round(offY + j * tsY) + 12;
                    if (x <= w && y <= h) ctx.fillText(`${col},${row}`, x, y);
                }
            }
            ctx.restore();
        }
    }

    #ensureGridPattern() {
        const tsX = this.#mapConfig.tileSize.x;
        const tsY = this.#mapConfig.tileSize.y;

        if (tsX < 1 || tsY < 1) {
            this.#gridPattern = null;
            return;
        }

        if (this.#gridPattern && this.#gridPatternTile.x === tsX && this.#gridPatternTile.y === tsY) return;

        this.#gridPattern = null;
        this.#gridPatternCanvas = null;

        const pxW = Math.max(1, Math.round(tsX));
        const pxH = Math.max(1, Math.round(tsY));

        const makeCanvas = (w, h) => {
            if (typeof OffscreenCanvas !== 'undefined') return new OffscreenCanvas(w, h);
            const c = document.createElement('canvas');
            c.width = w;
            c.height = h;
            return c;
        };

        const off = makeCanvas(pxW, pxH);
        const octx = off.getContext('2d');
        octx.imageSmoothingEnabled = false;
        octx.clearRect(0, 0, pxW, pxH);

        // draw crisp 1px lines in device pixels (top & left only)
        octx.lineWidth = 1;
        octx.strokeStyle = 'rgba(255,255,255,0.15)';
        octx.beginPath();
        octx.moveTo(0.5, 0);
        octx.lineTo(0.5, pxH); // left edge
        octx.moveTo(0, 0.5);
        octx.lineTo(pxW, 0.5); // top edge
        octx.stroke();

        let pattern = this.gameEngine.ctx.createPattern(off, 'repeat');

        if (!pattern) {
            const dom = document.createElement('canvas');
            dom.width = pxW;
            dom.height = pxH;
            dom.getContext('2d').drawImage(off, 0, 0);
            pattern = this.gameEngine.ctx.createPattern(dom, 'repeat');
            this.#gridPatternCanvas = dom;
        } else {
            this.#gridPatternCanvas = off;
        }

        this.#gridPattern = pattern;
        this.#gridPatternTile = { x: tsX, y: tsY };
        // this.#gridPatternDPR ;
    }

    #spawnEntity(components = {}, type, gridX = 0, gridY = 0) {
        /** @type {Entity} */
        let entity = this.entityManager.addEntity(type);

        for (let [componentType, args] of Object.entries(components)) {
            entity.addComponent(createComponent(componentType, ...args), componentType);
        }

        let worldCoords = this.#gridToWorldCentered(gridX, gridY);
        entity.getComponent(ComponentTypes.CTransform).position = worldCoords;

        let scaledBBox = this.#scaleBoundingRect(entity);

        let bBox = entity.getComponent(ComponentTypes.CBoundingBox);
        bBox.position = worldCoords;
        bBox.size = scaledBBox.scaledRect;

        // console.log('spawn entity');
        // console.log(components);
        // console.log(entity);
        return entity;
    }

    #stateToAnimation(stateEnum) {
        switch (stateEnum) {
            case EntityStates.WALKING_RIGHT:
            case EntityStates.WALKING_LEFT:
                return EntityStates.WALKING;
            case EntityStates.JUMPING:
            case EntityStates.FALLING:
                return EntityStates.JUMPING;
            case EntityStates.IDLE:
            case EntityStates.IDLE_LEFT:
            case EntityStates.ON_GROUND:
                return EntityStates.IDLE;
            default:
                return stateEnum;
        }
    }
}

export { PlayScene };
</file>

<file path="src/ui/print-json/print-json.js">
export const printJSON = (obj) => {
    console.log(JSON.stringify(obj, null, 2));
};

export const printJSONToFile = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'data.json';
    a.click();
    URL.revokeObjectURL(url);
};
</file>

<file path=".github/workflows/pages.yml">
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: "npm"
      - run: npm ci
      - run: npm run build
      - uses: actions/upload-pages-artifact@v3
        with:
          path: ./dist

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - id: deployment
        uses: actions/deploy-pages@v4
</file>

<file path="public/assets/d.js">
#include <iostream>

#include "SFML//Window/Event.hpp"
//#include "Scene_Menu.h"
#include "Scene_Play.h"
#include "Assets.h"
// #include "Physics.h"
#include "GameEngine.h"
#include "Components.h"
#include "Action.h"
#include "SFML/Graphics/RectangleShape.hpp"


Scene_Play::Scene_Play(GameEngine *gameEngine, const std::string &levelPath)
        : Scene(gameEngine), m_levelPath(levelPath) {
    init(levelPath);
}

void Scene_Play::init(const std::string &levelPath) {
    registerAction(sf::Keyboard::P, "PAUSE");
    registerAction(sf::Keyboard::Escape, "QUIT");
    registerAction(sf::Keyboard::T, "TOGGLE_TEXTURE");   // Toggle drawing (T)extures
    registerAction(sf::Keyboard::C, "TOGGLE_COLLISION"); // Toggle drawing (C)ollision Boxes
    registerAction(sf::Keyboard::G, "TOGGLE_GRID");      // Toggle drawing (G)rid

    // TODO: Register all other gameplay Actions
    // registerAction(sf::Keyboard::W, "JUMP");

    m_gridText.setCharacterSize(12);
    m_gridText.setFont(m_game->assets().getFont("Mario"));
    // m_gridText.setFont(m_game->assets().getFont("Tech"));

    loadLevel(levelPath);
}

vec2 Scene_Play::gridToMidPixel(float gridX, float gridY, std::shared_ptr<Entity> entity) {
    // TODO: This function takes in a grid (x,y) position and an Entity
    //       Return a vec2 indicating where the CENTER position of the Entity should be
    //       You must use the Entity's Animation size to position it correctly
    //       The size of the grid width and height is stored in m_gridSize.x and m_gridSize.y
    //       The bottom-left corner of the Animation should aligh with the bottom left of the grid cell

    return vec2(0, 0);
}

void Scene_Play::loadLevel(const std::string &fileName) {
    // reset the entity manager every time we load a level
    m_entityManager = EntityManager();

    // TODO: read in the level file and add the appropriate entities
    //       use the PlayerConfig struct m_playerConfig to store player properties
    //       this struct is defined at the top of Scene_Play.h

    // NOTE: all the code below is sample code which shows you how to
    //       set up and use entities with the new syntax, it should be removed

    spawnPlayer();

    // some sample entities
    auto brick = m_entityManager.addEntity("tile");
    // IMPORTANT: always add the CAnimation component first so that gridToMidPixel can compute correctly
    brick->addComponent<CAnimation>(m_game->assets().getAnimation("Brick"), true);
    brick->addComponent<CTransform>(vec2(96, 480));
    // NOTE: Your final code should position the entity with the grid x,y position read from the file:
    // brick->addComponent<CTransform>(gridToMidPixel(gridX, gridY, brick));

    if (brick->getComponent<CAnimation>().animation.getName() == "Brick") {
        std::cout << "This could be a good way of identifying if a tile is a brick!\n";
    }

    auto block = m_entityManager.addEntity("tile");
    // block->addComponent<CAnimation>(m_game->assets().getAnimation("Block"), true);
     block->addComponent<CAnimation>(m_game->assets().getAnimation("Ground"), true);
    block->addComponent<CTransform>(vec2(224, 480));
    // add a bounding box, this will now show up if we press the 'C' key
    // block->addComponent<CBoundingBox>(m_game->assets().getAnimation("Block").getSize());
     block->addComponent<CBoundingBox>(m_game->assets().getAnimation("Ground").getSize());

    auto question = m_entityManager.addEntity("tile");
    question->addComponent<CAnimation>(m_game->assets().getAnimation("Ground"), true);
    question->addComponent<CTransform>(vec2(352, 480));

    // NOTE: THIS IS INCREDIBLY IMPORTANT PLEASE READ THIS EXAMPLE
    //       Components are now returned as references rather than pointers
    //       If you do not specify a reference variable type, it will COPY the component
    //       Here is an example:
    //
    //       This will COPY the transform into the variable 'transform1' - it is INCORRECT
    //       Any changes you make to transform1 will not be changed inside the entity
    //       auto transform1 = entity->get<CTransform>()
    //
    //       This will REFERENCE the transform with the variable 'transform2' - it is CORRECT
    //       Now any changes you make to transform2 will be changed inside the entity
    //       auto& transform2 = entity->get<CTransform>()
}

void Scene_Play::spawnPlayer() {
    // here is a sample player entity which you can use to construct other entities
    m_player = m_entityManager.addEntity("player");
    m_player->addComponent<CAnimation>(m_game->assets().getAnimation("Stand"), true);
    m_player->addComponent<CTransform>(vec2(224, 352));
    m_player->addComponent<CBoundingBox>(vec2(48, 48));

    // TODO: be sure to add the remaining components to the player
}

void Scene_Play::spawnBullet(std::shared_ptr<Entity> entity) {
    // TODO: this should spawn a bullet at the given entity, going in the direction the entity is facing
}

void Scene_Play::update() {
    m_entityManager.update();

    // TODO: implement pause functionality

    sMovement();
    sLifespan();
    sCollision();
    sAnimation();
    sRender();
    // m_currentFrame++;
}

void Scene_Play::sMovement() {
    // TODO: Implement player movement/jumping based on its CInput component
    // TODO: Implement gravity's effect on the player
    // TODO: Implement the maximum player speed in both X and Y directions
    // NOTE: Setting an entity's scale.x to -1/1 will make it face to the left/right
}

void Scene_Play::sLifespan() {
    // TODO: Check lifespan of entities the have them, and destroy them if the go over
}

void Scene_Play::sCollision() {
    // REMEMBER: SFML's (0,0) position is in the TOP-LEFT corner
    //           This means jumping will have a negative y-component
    //           and gravity will have a positive y-component
    //           Also, something BELOW something else will hava a y value GREATER than it
    //           Also, something ABOVE something else will hava a y value LESS than it

    // TODO: Implement Physics::GetOverlap() function, use it inside this function

    // TODO: Implement bullet/tile collisions
    //       Destroy the tile if it has a Brick animation
    // TODO: Implement player/tile collisions and resolutions
    //       Update the CState component of the player to store whether
    //       it is currently on the ground or in the air. This will be
    //       used by the Animation system
    // TODO: Check to see if the player has fallen down a hole (y > height())
    // TODO: Don't let the player walk off the left side of the map
}

void Scene_Play::sDoAction(const Action &action) {
    if (action.type() == "START") {
        if (action.name() == "TOGGLE_TEXTURE") { m_drawTextures = !m_drawTextures; }
        else if (action.name() == "TOGGLE_COLLISION") { m_drawCollision = !m_drawCollision; }
        else if (action.name() == "TOGGLE_GRID") { m_drawGrid = !m_drawGrid; }
        else if (action.name() == "PAUSE") { setPaused(!m_paused); }
        else if (action.name() == "QUIT") { onEnd(); }
        else if (action.name() == "JUMP") {
            // m_player jump
        }
    } else if (action.type() == "END") {

    }
}

void Scene_Play::sAnimation() {
    // TODO: Complete the Animation class code first
}

void Scene_Play::onEnd() {
    // TODO: when the scene ends, change back to the MENU scene
    // use m_game->changeScene(correct params);
    // m_game->changeScene( "MENU", std::make_shared<Scene_Menu>(m_game));
}

void Scene_Play::sRender() {
    // color the background darker, so you know that the game is paused
    if (!m_paused) {
        m_game->window().clear(sf::Color(100, 100, 255));
    } else {
        m_game->window().clear(sf::Color(50, 50, 150));
    }

    // set the viewport of the window to be centered on the player if it's far enough right
    auto &pPos = m_player->getComponent<CTransform>().pos;
    float windowCenterX = std::max(m_game->window().getSize().x / 2.0f, pPos.x);
    sf::View view = m_game->window().getView();
    view.setCenter(windowCenterX, m_game->window().getSize().y - view.getCenter().y);
    m_game->window().setView(view);

    // draw all Entity textures / animations
    if (m_drawTextures) {
        for (const auto &e: m_entityManager.getEntities()) {
            auto &transform = e->getComponent<CTransform>();
            if (e->hasComponent<CAnimation>()) {
                auto &animation = e->getComponent<CAnimation>().animation;
                animation.getSprite().setRotation(transform.angle);
                animation.getSprite().setPosition(
                        transform.pos.x, transform.pos.y
                );
                animation.getSprite().setScale(
                        transform.scale.x, transform.scale.y
                );
                m_game->window().draw(animation.getSprite());
            }
        }
    }

    // draw all Entity collision bounding boxes with a rectangle shape
    if (m_drawCollision) {
        for (const auto &e: m_entityManager.getEntities()) {
            if (e->hasComponent<CBoundingBox>()) {
                auto &box = e->getComponent<CBoundingBox>();
                auto &transform = e->getComponent<CTransform>();
                sf::RectangleShape rect;
                rect.setSize(sf::Vector2f(box.size.x - 1, box.size.y - 1));
                rect.setOrigin(sf::Vector2f(box.halfSize.x, box.halfSize.y));
                rect.setPosition(transform.pos.x, transform.pos.y);
                rect.setFillColor(sf::Color(0, 0, 0, 0));
                rect.setOutlineColor(sf::Color::White);
                rect.setOutlineThickness(1);
                m_game->window().draw(rect);
            }
        }
    }

    // draw the grid so that can easily debug
    if (m_drawGrid) {
        float leftX = m_game->window().getView().getCenter().x - width() / 2.0;
        float rightX = leftX + width() + m_gridSize.x;
        float nextGridX = leftX - ((int) leftX % (int) m_gridSize.x);

        for (float x = nextGridX; x < rightX; x += m_gridSize.x) {
            drawLine(vec2(x, 0), vec2(x, height()));
        }

        for (float y = 0; y < height(); y += m_gridSize.y) {
            drawLine(vec2(leftX, height() - y), vec2(rightX, height() - y));

            for (float x = nextGridX; x < rightX; x += m_gridSize.x) {
                std::string xCell = std::to_string((int) x / (int) m_gridSize.x);
                std::string yCell = std::to_string((int) y / (int) m_gridSize.y);
                m_gridText.setString("(" + xCell + "," + yCell + ")");
                m_gridText.setPosition(x + 3, height() - y - m_gridSize.y + 2);
                m_game->window().draw(m_gridText);
            }
        }
    }
}
</file>

<file path="src/asset/assets.js">
import { loadJSON } from '../utils/file';
import { Texture } from '../utils/texture';

class Assets {
    // A map of all textures **loaded** for use in the game.
    #textureMap = new Map();
    #animationMap = new Map();
    #fontMap = new Map();

    // TODO: implement the methods of Assets class
    // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images
    /*
    async function draw() {
  // Wait for all images to be loaded:
  await Promise.all(
    Array.from(document.images).map(
      (image) =>
        new Promise((resolve) => image.addEventListener("load", resolve)),
    ),
  );

  // const ctx = document.getElementById("canvas").getContext("2d");
  // call drawImage() as usual
}
draw();
*/

    // TODO: implement the methods of Assets class
    async loadFromFile(path) {
        const data = await loadJSON(path);
        // Get all the images in the config file and the texture to the map
        // for (const texture of data.assets.textures) {
        //     this.#textureMap.set(texture.name, new Texture(texture.name, texture.atlas, texture.image));
        // }

        // // Get all the animations from the config json file
        // for (const anim of data.assets.textures) {
        // }
        // console.log(data.assets.animation);

        // // for (const texture of data.assets.animation)

        // console.log(this.#textureMap);
    }

    // addTexture(name, path) {}
    addAnimation(name, animation) {}
    addFont(name, path) {}
    getTexture(name) {}
    getAnimation(name) {}
    getFont(name) {}
}

export { Assets };
</file>

<file path="src/systems/collision.js">
import { Entity } from '../entityManager/entityManager';
import { Vector } from 'vecti';
import { ComponentTypes } from '../utils/enums';
import { BoundingBox, Transform } from '../components/components';

/**
 * Overlap information between two entities, using center-based AABBs.
 *
 * Coordinates & sizes:
 * - Positions are **centers** in world space.
 * - `ox` / `oy` are **non-negative penetration magnitudes** along X/Y.
 * - `dx` / `dy` are **signed center deltas**: (A.position - B.position).
 * - `mtv` is the **signed minimum translation vector** to ADD to A to separate it from B,
 *   chosen along the **shallow axis** (`axis`).
 *
 * When `overlapping` is false:
 * - `ox` and `oy` are 0,
 * - `mtv` is (0, 0),
 * - `axis` is `null`.
 *
 * @typedef {Object} OverlapData
 * @property {boolean} overlapping - True if A and B overlap (i.e., `ox > 0 && oy > 0`).
 * @property {number} ox - Penetration magnitude along X (â‰¥ 0).
 * @property {number} oy - Penetration magnitude along Y (â‰¥ 0).
 * @property {number} dx - Signed center delta X: `A.x - B.x`.
 * @property {number} dy - Signed center delta Y: `A.y - B.y`.
 * @property {'x'|'y'|null} axis - Shallow axis of penetration; `'x'`, `'y'`, or `null` if not overlapping.
 * @property {Vector} mtv - Signed vector to add to **A** to minimally separate from **B`.
 */

class CollisionSystem {
    /**
     * Represents the overlapping for the entity
     */

    constructor() {}

    /**
     * Computes center-based AABB overlap between two entities.
     * @param {Entity} a
     * @param {Entity} b
     * @returns {OverlapData}
     */

    calculateOverlap(a, b) {
        /** @type {BoundingBox} */
        const rectA = a.getComponent(ComponentTypes.CBoundingBox);
        /** @type {Transform} */
        const trA = a.getComponent(ComponentTypes.CTransform);
        /** @type {BoundingBox} */
        const rectB = b.getComponent(ComponentTypes.CBoundingBox);
        /** @type {Transform} */
        const trB = b.getComponent(ComponentTypes.CTransform);
        const dxRaw = trA.position.x - trB.position.x;
        const dyRaw = trA.position.y - trB.position.y;
        const dx = Math.abs(dxRaw);
        const dy = Math.abs(dyRaw);

        const ox = rectA.halfSize.x + rectB.halfSize.x - dx;
        const oy = rectA.halfSize.y + rectB.halfSize.y - dy;

        const overlapping = ox > 0 && oy > 0;

        if (!overlapping) {
            return {
                overlapping: false,
                ox: 0,
                oy: 0,
                dx: dxRaw,
                dy: dyRaw,
                axis: null,
                mtv: new Vector(0, 0), // minimum translation vector
            };
        }

        // Choose the shallow axis and give MTV a SIGN that separates A from B
        // Sign convention: MTV is the vector to ADD to A to separate it from B.
        let mtv, axis;
        if (ox < oy) {
            axis = 'x';
            const sx = dxRaw === 0 ? 0 : dxRaw > 0 ? +1 : -1; // if A is to the right of B, push A further right
            mtv = new Vector(ox * sx, 0);
        } else {
            axis = 'y';
            const sy = dyRaw === 0 ? 0 : dyRaw > 0 ? +1 : -1; // if A is below B, push A further down
            mtv = new Vector(0, oy * sy);
        }

        return {
            overlapping,
            ox,
            oy, // penetration magnitudes
            dx: dxRaw,
            dy: dyRaw, // signed center deltas
            axis, // 'x' or 'y'
            mtv, // signed separation vector for A
        };
    }
}

export { CollisionSystem };
</file>

<file path="src/ui/buttons/entityList/entities.template.html">
<template id="entityItemTemplate">
    <li class="entity-card" data-entity-id="">
        <article>
            <header class="entity-header">
                <strong>
                    <span data-entity-tag></span>
                    <span>#<span data-entity-id></span></span>
                </strong>
                <small>
                    <label>
                        <input type="checkbox" data-field="active" />
                        active
                    </label>
                </small>
            </header>
        </article>
    </li>
</template>
</file>

<file path="src/ui/buttons/entityList/entity.base.css">
/* ===== Entity Editor (template styles) ===== */

/* Light/Dark palette */
:root {
    --bg: #ffffff;
    --panel: #f6f7fb;
    --card: #ffffff;
    --text: #16191e;
    --input-text: #1c1f24;
    --muted: #6b7280;
    --border: #e5e7eb;
    --accent: #3b82f6;
    --accent-contrast: #ffffff;
    --shadow: 0 1px 2px rgba(0, 0, 0, 0.06), 0 4px 12px rgba(0, 0, 0, 0.06);
    --input-bg: #eff2f6;
    --red: #ef4444;
    --blue: #3b82f6;
    --green: #16a34a;
    --yellow: #f59e0b;
}

@media (prefers-color-scheme: dark) {
    :root {
        --bg: #0f1115;
        --panel: #151922;
        --card: #0f141b;
        --text: #e5e7eb;
        --input-text: #1c1f24;
        --muted: #9aa3b2;
        --border: #1f2530;
        --accent: #60a5fa;
        --accent-contrast: #0b1020;
        --shadow: 0 1px 2px rgba(0, 0, 0, 0.5), 0 6px 18px rgba(0, 0, 0, 0.35);
    }
}

/* Card (the <li> root in the template) */
.entity-card {
    background: var(--card);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: var(--shadow);
    padding: 14px;
    margin: 10px 0;

    cursor: default;
}

details {
    cursor: pointer;
}

/* Header */
.entity-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
    gap: 12px;
}

.entity-header strong {
    font-size: 14px;
    font-weight: 700;
    display: inline-flex;
    gap: 8px;
}

.entity-header small {
    color: var(--muted);
    font-size: 12px;
}

.entity-header input[type='checkbox'] {
    vertical-align: middle;
    accent-color: var(--accent);
}

/* Component sections */
.component {
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
    background: var(--panel);
    margin: 10px 0 0;
}

.component h4 {
    margin: 0 0 10px;
    font-size: 13px;
    letter-spacing: 0.02em;
}

/* Forms */
.component-form {
    display: grid;
    gap: 10px;
}

/* Row = responsive field group */
.row {
    display: grid;
    grid-template-columns: repeat(4, minmax(100px, 1fr));
    gap: 10px;
}

@media (max-width: 520px) {
    .row {
        grid-template-columns: 1fr;
    }
}

/* Labels & inputs */
.input-container {
    /* 
    the label and input wrapper should be side-by-side
    */
    display: grid;
    gap: 6px;
    grid-template-columns: auto 1fr;
}
/*  colors  */

.text-red {
    color: var(--red);
}

.text-green {
    color: rgb(99, 255, 99);
}

.text-blue {
    color: rgb(99, 99, 255);
}

.icon-large {
    font-size: large;
}

.text-yellow {
    color: rgb(255, 255, 99);
    font-size: large;
}

label {
    display: grid;
    gap: 6px;
    font-size: 12px;
    color: var(--muted);
}

/* input.hidden {
    display: none;
} */
.value-hidden {
    display: none;
}
input[type='number'],
input[type='text'] {
    max-width: 60px;
    max-height: 32px;
    box-sizing: border-box;
    border: 1px solid var(--accent);
    border-radius: 4px;
    background: var(--input-bg);
    color: var(--input-text);
    outline: none;
    transition: border-color 0.15s ease, box-shadow 0.15s ease;
}

input[type='number']:focus,
input[type='text']:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent) 25%, transparent);
}

/* Checkboxes in rows */
.row .checkbox,
label.checkbox {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    color: var(--muted);
}

input[type='checkbox'] {
    accent-color: var(--accent);
}

/* Actions */
.actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 6px;
}

.actions button {
    appearance: none;
    border: 1px solid var(--border);
    background: var(--card);
    color: var(--text);
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 12px;
    cursor: pointer;
    transition: border-color 0.15s ease, transform 0.05s ease;
}

.actions button[data-action='delete-component'] {
    border: none;
}

.actions button[data-action='refresh-component'] {
    background-color: var(--green);
    color: var(--accent-contrast);
}

.actions button:hover {
    border-color: var(--accent);
}

.actions button[data-action='save-component'] {
    background: var(--accent);
    color: var(--accent-contrast);
    border-color: var(--accent);
}

.actions button:active {
    transform: translateY(1px);
}

.actions {
    li {
        list-style: none;
    }
}

/* Utility: tighten vertical rhythm between components */
.component + .component {
    margin-top: 12px;
}
</file>

<file path="src/ui/buttons/button.js">
function createButton() {}
</file>

<file path="src/ui/dock/dock.css">
/* ---- Dock layout ---- */
.dock-root {
    --dock-bg: #0f1115;
    --dock-surface: #151821;
    --dock-border: #2a3040;
    --dock-size-left: 320px; /* initial */
    --dock-size-right: 360px; /* initial */
    --dock-size-bottom: 260px; /* if you add bottom later */
    position: relative;
    inset: 0;
    display: grid;
    height: 100%;
    grid-template-columns: var(--dock-size-left) 6px 1fr 6px var(--dock-size-right);
    grid-template-rows: 1fr;
    background: var(--dock-bg);
}

/* Zones */
.dock-left,
.dock-right,
.dock-bottom {
    background: #151821;
    border-right: 1px solid var(--dock-border);
    overflow: hidden;
}
.dock-right {
    border-right: none;
    border-left: 1px solid var(--dock-border);
}

.dock-center {
    position: relative;
    overflow: hidden;
    background: #0c0e12;
}

/* Splitters */
.dock-splitter {
    background: transparent;
    position: relative;
    z-index: 5;
}
.dock-splitter:hover {
    background: rgba(255, 255, 255, 0.03);
}
.dock-splitter.vertical {
    cursor: col-resize;
}
.dock-splitter.horizontal {
    cursor: row-resize;
}

/* Canvas fills center */
.dock-center canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* Optional header in docks if you want */
.dock-header {
    font: 600 12px/1 system-ui, Segoe UI, Roboto, sans-serif;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: #8b93a7;
    padding: 10px 14px;
    border-bottom: 1px solid var(--dock-border);
    background: linear-gradient(180deg, #181c25 0%, #141826 100%);
}

/* Use the tabs styles from earlier for content inside docks */
</file>

<file path="src/ui/dock/dock.js">
// dock.js
// Minimal dock system: resizable left/right areas that host Tabs instances.

import { Tabs } from './tabs.js';

export class DockManager extends EventTarget {
    /**
     * @param {HTMLElement} root  Container that should fill the screen/parent.
     * @param {{storageKey?:string, withRight?:boolean}} [opts]
     */
    constructor(root, opts = {}) {
        super();
        this.root = root;
        this.storageKey = opts.storageKey ?? 'ui.dock.v1';
        this.withRight = opts.withRight ?? true;

        this.#buildLayout();
        this.#restoreSizes();
        this.#wireSplitters();
    }

    /** Accessors for the embedded Tabs instances */
    get leftTabs() {
        return this._leftTabs;
    }
    get rightTabs() {
        return this._rightTabs;
    } // may be undefined if withRight=false

    /** Programmatically set the left/right sizes (in px) and persist */
    setSize(which, px) {
        const min = 200,
            max = 700;
        px = Math.max(min, Math.min(max, Math.round(px)));
        if (which === 'left') this.root.style.setProperty('--dock-size-left', px + 'px');
        if (which === 'right') this.root.style.setProperty('--dock-size-right', px + 'px');
        this.#persistSizes();
    }

    // ---------- internal ----------

    #buildLayout() {
        this.root.classList.add('dock-root');

        // Left dock
        const left = document.createElement('div');
        left.className = 'dock-left';
        const splitL = document.createElement('div');
        splitL.className = 'dock-splitter vertical';
        splitL.dataset.side = 'left';

        // Center (canvas goes here)
        const center = document.createElement('div');
        center.className = 'dock-center';

        // Right dock (optional)
        const splitR = document.createElement('div');
        let right = null;
        if (this.withRight) {
            splitR.className = 'dock-splitter vertical';
            splitR.dataset.side = 'right';
            right = document.createElement('div');
            right.className = 'dock-right';
        }

        // Grid slots
        // columns: left | splitL | center | splitR | right
        this.root.append(left, splitL, center);
        if (this.withRight) this.root.append(splitR, right);

        // Create Tabs inside left/right
        const leftShell = document.createElement('div');
        leftShell.className = 'dock-shell';
        left.appendChild(leftShell);
        this._leftTabs = new Tabs(leftShell, { title: 'Left Dock', storageKey: this.storageKey + '.left' });

        if (this.withRight) {
            const rightShell = document.createElement('div');
            rightShell.className = 'dock-shell';
            right.appendChild(rightShell);
            this._rightTabs = new Tabs(rightShell, { title: 'Right Dock', storageKey: this.storageKey + '.right' });
        }

        // Expose center for your canvas
        this.centerEl = center;
    }

    #wireSplitters() {
        const onDown = (e) => {
            const side = e.currentTarget.dataset.side;
            const rect = this.root.getBoundingClientRect();
            const startX = e.clientX;
            const startLeft = parseFloat(getComputedStyle(this.root).getPropertyValue('--dock-size-left'));
            const startRight = parseFloat(getComputedStyle(this.root).getPropertyValue('--dock-size-right'));

            const onMove = (ev) => {
                if (side === 'left') {
                    const delta = ev.clientX - startX;
                    this.setSize('left', startLeft + delta);
                } else if (side === 'right') {
                    const delta = startX - ev.clientX;
                    this.setSize('right', startRight + delta);
                }
                ev.preventDefault();
            };
            const onUp = () => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onUp);
            };
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
            e.preventDefault();
        };

        this.root.querySelectorAll('.dock-splitter.vertical').forEach((s) => {
            s.addEventListener('mousedown', onDown);
        });
    }

    #persistSizes() {
        try {
            const styles = getComputedStyle(this.root);
            const left = parseInt(styles.getPropertyValue('--dock-size-left')) || 320;
            const right = parseInt(styles.getPropertyValue('--dock-size-right')) || 360;
            localStorage.setItem(this.storageKey + '.sizes', JSON.stringify({ left, right }));
        } catch {}
    }

    #restoreSizes() {
        try {
            const raw = localStorage.getItem(this.storageKey + '.sizes');
            if (!raw) return;
            const { left, right } = JSON.parse(raw);
            if (left) this.root.style.setProperty('--dock-size-left', left + 'px');
            if (right) this.root.style.setProperty('--dock-size-right', right + 'px');
        } catch {}
    }
}
</file>

<file path="src/ui/tabs/tabs-retro.css">
/* ==== RETRO (Win95/98) TAB THEME ======================================= */
/* Palette + metrics */
.tab-container {
    --retro-bg: #c0c0c0; /* classic dialog gray */
    --retro-face: #dcdcdc; /* raised face */
    --retro-dark: #808080; /* dark edge */
    --retro-darker: #404040; /* shadow edge */
    --retro-light: #ffffff; /* light edge */
    --retro-text: #000000;
    --retro-accent: #000080; /* Win95 blue */
    --retro-hover: #e8e8e8;
    --retro-active: #b8b8b8;
    --retro-font: 'Tahoma', 'MS Sans Serif', system-ui, sans-serif;

    color: var(--retro-text);
    background: var(--retro-bg);
    border: 2px solid var(--retro-dark);
    /* 3D raised frame */
    box-shadow: inset -1px -1px 0 var(--retro-dark), inset 1px 1px 0 var(--retro-light),
        inset -2px -2px 0 var(--retro-darker), inset 2px 2px 0 var(--retro-face);
    border-radius: 0;
    overflow: hidden;
    font-family: var(--retro-font);
}

/* subtle dithered plastic feel */
.tab-container::before {
    content: '';
    display: block;
    height: 18px;
    background: repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.18) 0 2px, rgba(255, 255, 255, 0) 2px 4px);
    border-bottom: 1px solid var(--retro-dark);
}

/* ===== Tabs header row (toolbar strip) */
.tab-container .tabs {
    display: flex;
    gap: 2px;
    padding: 3px;
    background: var(--retro-bg);
    border-bottom: 2px solid var(--retro-dark);
    box-shadow: inset -1px -1px 0 var(--retro-dark), inset 1px 1px 0 var(--retro-light);
    overflow-x: auto;
    scrollbar-width: thin;
}
.tab-container .tabs::-webkit-scrollbar {
    height: 12px;
}
.tab-container .tabs::-webkit-scrollbar-thumb {
    background: var(--retro-dark);
    border: 2px solid var(--retro-bg);
}

/* ===== Tab buttons (raised, beveled) */
.tab-links {
    position: relative;
    appearance: none;
    border: 2px solid var(--retro-dark);
    box-shadow: inset -1px -1px 0 var(--retro-dark), inset 1px 1px 0 var(--retro-light),
        inset -2px -2px 0 var(--retro-darker), inset 2px 2px 0 var(--retro-face);
    background: var(--retro-face);
    color: var(--retro-text);
    padding: 4px 10px 3px;
    border-radius: 0;
    font: 12px/1 var(--retro-font);
    cursor: default;
    white-space: nowrap;
}
.tab-links:hover {
    background: var(--retro-hover);
}

.tab-links:focus-visible {
    outline: 1px dotted var(--retro-text);
    outline-offset: -4px;
}

/* Active tab: pressed look + top border merges with content */
.tab-links.active {
    background: var(--retro-active);
    /* invert bevel for pressed */
    box-shadow: inset -1px -1px 0 var(--retro-light), inset 1px 1px 0 var(--retro-dark),
        inset -2px -2px 0 var(--retro-face), inset 2px 2px 0 var(--retro-darker);
    border-bottom-color: var(--retro-active);
}
.tab-links.active::after {
    /* tiny accent line like selected title bar */
    content: '';
    position: absolute;
    left: 2px;
    right: 2px;
    top: 1px;
    height: 2px;
    background: var(--retro-accent);
}

/* Optional close button if you have one */
.tab-close {
    margin-left: 8px;
    width: 14px;
    height: 14px;
    display: inline-grid;
    place-items: center;
    border: 1px solid var(--retro-dark);
    box-shadow: inset -1px -1px 0 var(--retro-dark), inset 1px 1px 0 var(--retro-light);
    background: var(--retro-face);
    color: var(--retro-text);
    font: 12px/1 var(--retro-font);
    padding: 0;
}
.tab-close:hover {
    background: var(--retro-hover);
}

/* ===== Panels (sunken 3D client area) */
.tab-content {
    display: none;
    background: var(--retro-face);
    padding: 10px;
    min-height: 220px;

    /* sunken panel look */
    border-top: 2px solid var(--retro-light);
    box-shadow: inset 1px 1px 0 var(--retro-light), inset -1px -1px 0 var(--retro-dark),
        inset 2px 2px 0 var(--retro-face), inset -2px -2px 0 var(--retro-darker);
}
.tab-content.active {
    display: block;
}

/* Retro form bits inside panels */
.tab-content button,
.tab-content input,
.tab-content select {
    font: 12px/1 var(--retro-font);
    color: var(--retro-text);
    background: var(--retro-face);
    border: 2px solid var(--retro-dark);
    box-shadow: inset -1px -1px 0 var(--retro-dark), inset 1px 1px 0 var(--retro-light);
    border-radius: 0;
    padding: 3px 6px;
}
.tab-content button:hover {
    background: var(--retro-hover);
}
.tab-content button:active {
    box-shadow: inset -1px -1px 0 var(--retro-light), inset 1px 1px 0 var(--retro-dark);
    background: var(--retro-active);
}

/* If you show icons/emoji in tab labels, keep them crisp */
.tab-links .tab-icon {
    image-rendering: pixelated;
}
</file>

<file path="src/ui/tabs/tabs.js">
export class Tabs extends EventTarget {
    /**
     * @param {HTMLElement} container  Wrapper element where the tabs UI will render.
     * @param {{title?:string, storageKey?:string}} [opts]
     */
    constructor(container, opts = {}) {
        super();
        this.container = container;
        this.title = opts.title ?? 'Panels';
        this.storageKey = opts.storageKey ?? 'ui.tabs.v2';
        this.tabs = new Map(); // id -> meta
        this.order = []; // tab id order
        this.activeId = null;

        this.#buildShell();
        this.#restore();
        this.#wireKeyboardNav();
    }

    // ---------- Public API ----------

    /**
     * Add a tab.
     * @param {{
     *   id:string, title:string, icon?:string, tooltip?:string,
     *   closable?:boolean, badge?:string|number,
     *   mount?:(root:HTMLElement)=>void, unmount?:(root:HTMLElement)=>void,
     *   onShow?:(root:HTMLElement)=>void, onHide?:(root:HTMLElement)=>void,
     *   active?:boolean
     * }} conf
     */
    addTab(conf) {
        if (!conf?.id || !conf?.title) throw new Error('addTab requires {id, title}');
        if (this.tabs.has(conf.id)) throw new Error(`Tab '${conf.id}' already exists`);

        // Elements
        const btn = document.createElement('button');
        btn.className = 'tab-links';
        btn.type = 'button';
        btn.role = 'tab';
        btn.id = `tab-${conf.id}`;
        btn.dataset.tabId = conf.id;
        btn.setAttribute('aria-selected', 'false');
        btn.setAttribute('tabindex', '-1');
        if (conf.tooltip) btn.title = conf.tooltip;

        const label = document.createElement('span');
        label.className = 'tab-title';
        label.textContent = conf.title;

        if (conf.icon) {
            const ic = document.createElement('span');
            ic.className = 'tab-icon';
            ic.textContent = conf.icon;
            btn.append(ic);
        }
        btn.append(label);

        const badge = document.createElement('span');
        badge.className = 'tab-badge';
        if (conf.badge != null) {
            badge.textContent = String(conf.badge);
            btn.append(badge);
        }

        let closeBtn = null;
        if (conf.closable) {
            closeBtn = document.createElement('button');
            closeBtn.className = 'tab-close';
            closeBtn.type = 'button';
            closeBtn.setAttribute('aria-label', `Close ${conf.title}`);
            closeBtn.textContent = 'Ã—';
            btn.append(closeBtn);
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.removeTab(conf.id);
            });
        }

        const panel = document.createElement('div');
        panel.className = 'tab-content';
        panel.id = conf.id;
        panel.role = 'tabpanel';
        panel.setAttribute('aria-labelledby', btn.id);
        panel.hidden = true;

        this.tablist.append(btn);
        this.contentRegion.append(panel);

        const meta = {
            ...conf,
            button: btn,
            badgeEl: badge,
            panel,
            mounted: false,
        };
        this.tabs.set(conf.id, meta);
        this.order.push(conf.id);

        btn.addEventListener('click', () => this.select(conf.id));

        this.#persist();

        this.dispatchEvent(new CustomEvent('tab:add', { detail: { id: conf.id } }));

        const shouldAutoSelect =
            conf.active || (this.activeId == null && (!this._restoredActiveId || this._restoredActiveId === conf.id));

        if (shouldAutoSelect) this.select(conf.id);

        if (!this.order.includes(conf.id)) this.order.push(conf.id);
    }

    /** Remove a tab by id. */
    removeTab(id) {
        const meta = this.tabs.get(id);
        if (!meta) return;
        if (meta.unmount && meta.mounted) meta.unmount(meta.panel);
        meta.button.remove();
        meta.panel.remove();
        this.tabs.delete(id);
        this.order = this.order.filter((x) => x !== id);

        if (this.activeId === id) {
            const next = this.order[this.order.length - 1] || null; // select previous tab if any
            this.activeId = null;
            if (next) this.select(next);
        }
        this.#persist();
        this.dispatchEvent(new CustomEvent('tab:remove', { detail: { id } }));
    }

    /** Select a tab by id. */
    select(id) {
        if (!this.tabs.has(id)) return;

        const prev = this.activeId ? this.tabs.get(this.activeId) : null;
        const next = this.tabs.get(id);

        // Deactivate previous
        if (prev) {
            prev.button.classList.remove('active');
            prev.button.setAttribute('aria-selected', 'false');
            prev.button.setAttribute('tabindex', '-1');
            prev.panel.hidden = true;
            prev.panel.classList.remove('active');
            prev.onHide?.(prev.panel);
        }

        // Activate next
        this.activeId = id;
        next.button.classList.add('active');
        next.button.setAttribute('aria-selected', 'true');
        next.button.setAttribute('tabindex', '0');
        next.panel.hidden = false;
        next.panel.classList.add('active');
        next.button.focus({ preventScroll: true });

        // Lazy mount
        if (!next.mounted && next.mount) {
            next.mount(next.panel);
            next.mounted = true;
        }
        next.onShow?.(next.panel);

        this.#persist();
        this.dispatchEvent(new CustomEvent('tab:select', { detail: { id } }));
    }

    /** Update tab metadata: title, icon, badge, tooltip. */
    update(id, patch = {}) {
        const t = this.tabs.get(id);
        if (!t) return;
        if (patch.title) t.panel.setAttribute('aria-label', patch.title);
        if (patch.title) t.button.querySelector('.tab-title').textContent = patch.title;
        if (patch.icon != null) {
            let ic = t.button.querySelector('.tab-icon');
            if (patch.icon === '' || patch.icon === false) {
                ic?.remove();
            } else {
                if (!ic) {
                    ic = document.createElement('span');
                    ic.className = 'tab-icon';
                    t.button.prepend(ic);
                }
                ic.textContent = patch.icon;
            }
        }
        if ('badge' in patch) {
            if (patch.badge == null || patch.badge === '') {
                t.badgeEl.textContent = '';
                t.badgeEl.style.display = 'none';
            } else {
                t.badgeEl.textContent = String(patch.badge);
                t.badgeEl.style.display = '';
            }
        }
        if (patch.tooltip != null) t.button.title = patch.tooltip;
    }

    /** Returns the active tab id or null. */
    get active() {
        return this.activeId;
    }

    /** Reorder tabs by array of ids. */
    reorder(ids) {
        if (!Array.isArray(ids)) return;
        // keep only known ids in given order + append any missing
        const set = new Set(ids.filter((id) => this.tabs.has(id)));
        this.order = [...set, ...this.order.filter((id) => !set.has(id))];
        // apply DOM order
        this.order.forEach((id) => this.tablist.append(this.tabs.get(id).button));
        this.#persist();
        this.dispatchEvent(new CustomEvent('tab:reorder', { detail: { order: this.order.slice() } }));
    }

    // ---------- Private ----------

    #buildShell() {
        this.container.classList.add('tab-container');
        // Optional title bar
        const titleBar = document.createElement('div');
        titleBar.className = 'tab-titlebar';
        titleBar.textContent = this.title;

        const tablist = document.createElement('div');
        tablist.className = 'tabs';
        tablist.role = 'tablist';
        tablist.setAttribute('aria-label', this.title);

        const content = document.createElement('div');
        content.className = 'tab-contents';

        this.container.replaceChildren(titleBar, tablist, content);
        this.tablist = tablist;
        this.contentRegion = content;
    }

    #wireKeyboardNav() {
        this.tablist.addEventListener('keydown', (e) => {
            const ids = this.order;
            if (!ids.length) return;
            const idx = ids.indexOf(this.activeId);
            if (e.key === 'ArrowRight') {
                this.select(ids[(idx + 1) % ids.length]);
                e.preventDefault();
            } else if (e.key === 'ArrowLeft') {
                this.select(ids[(idx - 1 + ids.length) % ids.length]);
                e.preventDefault();
            } else if (e.key === 'Home') {
                this.select(ids[0]);
                e.preventDefault();
            } else if (e.key === 'End') {
                this.select(ids[ids.length - 1]);
                e.preventDefault();
            } else if (e.ctrlKey && e.key === 'Tab') {
                this.select(ids[(idx + (e.shiftKey ? -1 : 1) + ids.length) % ids.length]);
                e.preventDefault();
            }
        });
    }

    #persist() {
        try {
            const data = { order: this.order, activeId: this.activeId };
            localStorage.setItem(this.storageKey, JSON.stringify(data));
        } catch {}
    }

    #restore() {
        try {
            const raw = localStorage.getItem(this.storageKey);
            if (!raw) return;
            const { order, activeId } = JSON.parse(raw);
            if (Array.isArray(order)) {
                // keep unique strings only
                this.order = [...new Set(order.filter((id) => typeof id === 'string'))];
            }
            // don't set active yet; just remember it
            this._restoredActiveId = typeof activeId === 'string' ? activeId : null;
            this.activeId = null;
        } catch {}
    }
}
</file>

<file path="src/ui/tabs/theme-crt.css">
[data-theme='crt'] {
    --ui-text: #a6ff7a;
    --ui-accent: #a6ff7a;
    --ui-surface: #061006;
    --ui-surface-2: #0b1a0b;
    --ui-bg: #020602;
    --ui-border: #0f2a0f;
    --ui-border-width: 1px;
    --ui-radius: 4px;

    --ui-shadow: 0 0 20px rgba(166, 255, 122, 0.08);

    --hdr-bg: #061006;
    --hdr-border: 1px solid #0f2a0f;
    --hdr-font: 600 11px/1 ui-monospace, monospace;
    --hdr-transform: none;

    --tabs-bg: #061006;
    --tab-gap: 2px;
    --tab-border: 1px solid #0f2a0f;
    --tab-bg: #0b1a0b;
    --tab-hover-bg: #0e230e;

    --tab-active-bg: #0e230e;
    --tab-active-border: 1px solid #1e4d1e;
    --tab-active-shadow: inset 0 0 0 1px #153a15;
    --tab-accent-h: 0;

    --panel-bg: repeating-linear-gradient(180deg, rgba(166, 255, 122, 0.06) 0 2px, rgba(0, 0, 0, 0) 2px 4px), #061006;

    --focus-outline: 1px dashed #a6ff7a;
    --focus-offset: 2px;
}
</file>

<file path="src/ui/tabs/theme-light.css">
[data-theme='lighting'] {
    --ui-text: #f5f5ff;
    --ui-accent: #ff2bd6;
    --ui-surface: #060f368d;
    --ui-surface-2: #060f368d;
    --ui-bg: #090b1600;
    --ui-border: #0d101e;
    --ui-border-width: 1px;
    --ui-radius: 12px;

    --ui-shadow: 0 12px 30px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 43, 214, 0.06);

    /* Header */
    --hdr-bg: linear-gradient(90deg, #1a0b2b, #0b1a2b);
    --hdr-border: 1px solid #2a2f46;
    --hdr-font: 700 11px/1 'Orbitron', system-ui, sans-serif;
    --hdr-transform: uppercase;
    --hdr-tracking: 0.08em;

    --tabs-bg: #11162a7d;
    --tab-gap: 6px;
    --tab-border: 1px solid #293050;
    --tab-bg: #141b33;
    --tab-hover-bg: #19224a;

    --tab-active-bg: #0f142853;
    --tab-active-border: 1px solid #3a4270;
    --tab-active-shadow: 0 0 0 1px rgba(255, 43, 214, 0.18), 0 8px 20px rgba(0, 0, 0, 0.35);
    --tab-accent-h: 2px;
    --tab-accent-radius: 2px;

    --panel-bg: radial-gradient(1200px 400px at 10% -10%, rgba(255, 43, 214, 0.08), transparent),
        radial-gradient(1200px 400px at 90% -10%, rgba(0, 255, 255, 0.08), transparent), #0b0e1a40;

    --focus-outline: 2px solid #ff2bd6;
    --focus-offset: 1px;
}
</file>

<file path="src/ui/tabs/theme-mac9.css">
[data-theme='mac9'] {
    --ui-text: #000;
    --ui-accent: #0a84ff;
    --ui-surface: #efefef;
    --ui-surface-2: #e6e6e6;
    --ui-bg: #f4f4f4;
    --ui-border: #b9b9b9;
    --ui-border-width: 1px;
    --ui-radius: 10px;

    --ui-shadow: 0 10px 24px rgba(0, 0, 0, 0.12);

    --hdr-bg: linear-gradient(#fdfdfd, #e9e9e9);
    --hdr-border: 1px solid #cfcfcf;
    --hdr-font: 600 12px/1 'Chicago', system-ui, sans-serif;
    --hdr-transform: none;
    --hdr-tracking: 0;

    --tabs-bg: #efefef;
    --tab-gap: 6px;
    --tab-radius: 10px 10px 0 0;
    --tab-border: 1px solid #cfcfcf;
    --tab-bg: #f8f8f8;
    --tab-hover-bg: #ffffff;

    --tab-active-bg: #ffffff;
    --tab-active-border: 1px solid #bdbdbd;
    --tab-active-shadow: 0 1px 0 rgba(0, 0, 0, 0.05);
    --tab-accent-h: 0; /* no accent bar */

    --panel-bg: #ffffff;
    --panel-pad: 18px;
    --focus-outline: 2px solid color-mix(in oklab, #0a84ff 60%, transparent);
}
</file>

<file path="src/ui/tabs/theme-synthwave.css">
[data-theme='synthwave'] {
    --ui-text: #f5f5ff;
    --ui-accent: #ff2bd6;
    --ui-surface: #0b0e1a;
    --ui-surface-2: #11162a;
    --ui-bg: #090b16;
    --ui-border: #2a2f46;
    --ui-border-width: 1px;
    --ui-radius: 12px;

    --ui-shadow: 0 12px 30px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 43, 214, 0.06);

    --hdr-bg: linear-gradient(90deg, #1a0b2b, #0b1a2b);
    --hdr-border: 1px solid #2a2f46;
    --hdr-font: 700 11px/1 'Orbitron', system-ui, sans-serif;
    --hdr-transform: uppercase;
    --hdr-tracking: 0.08em;

    --tabs-bg: #11162a;
    --tab-gap: 6px;
    --tab-border: 1px solid #293050;
    --tab-bg: #141b33;
    --tab-hover-bg: #19224a;

    --tab-active-bg: #0f1428;
    --tab-active-border: 1px solid #3a4270;
    --tab-active-shadow: 0 0 0 1px rgba(255, 43, 214, 0.18), 0 8px 20px rgba(0, 0, 0, 0.35);
    --tab-accent-h: 2px;
    --tab-accent-radius: 2px;

    --panel-bg: radial-gradient(1200px 400px at 10% -10%, rgba(255, 43, 214, 0.08), transparent),
        radial-gradient(1200px 400px at 90% -10%, rgba(0, 255, 255, 0.08), transparent), #0b0e1a;

    --focus-outline: 2px solid #ff2bd6;
    --focus-offset: 1px;
}
</file>

<file path="src/ui/tabs/theme-win95.css">
/* Apply theme by wrapping container in [data-theme="win95"] */
[data-theme='win95'] {
    --ui-text: #000;
    --ui-accent: #000080;
    --ui-surface: #dcdcdc;
    --ui-surface-2: #c0c0c0;
    --ui-bg: #dcdcdc;
    --ui-border: #808080;
    --ui-border-width: 2px;
    --ui-radius: 0;

    --ui-shadow: inset -1px -1px 0 #808080, inset 1px 1px 0 #fff, inset -2px -2px 0 #404040, inset 2px 2px 0 #dcdcdc;

    --hdr-bg: linear-gradient(#e6e6e6, #d3d3d3);
    --hdr-border: 1px solid #808080;
    --hdr-font: 700 12px/1 'Tahoma', 'MS Sans Serif', system-ui, sans-serif;

    --tabs-bg: #c0c0c0;
    --tab-gap: 2px;
    --tab-btn-pad: 4px 10px 3px;
    --tab-radius: 0;
    --tab-border: 2px solid #808080;
    --tab-shadow: inset -1px -1px 0 #808080, inset 1px 1px 0 #fff, inset -2px -2px 0 #404040, inset 2px 2px 0 #dcdcdc;
    --tab-hover-bg: #e8e8e8;

    --tab-active-bg: #b8b8b8;
    --tab-active-border: 2px solid #808080;
    --tab-active-shadow: inset -1px -1px 0 #fff, inset 1px 1px 0 #808080, inset -2px -2px 0 #dcdcdc,
        inset 2px 2px 0 #404040;

    --tab-accent-h: 2px;
    --tab-accent-radius: 0;

    --panel-pad: 10px;
    --panel-bg: #dcdcdc;
}
</file>

<file path="src/ui/entities.template.html">
<template id="entityItemTemplate">
    <li class="entity-card" data-entity-id="">
        <article>
            <header class="entity-header">
                <strong>
                    <span data-entity-tag></span>
                    <span>#<span data-entity-id></span></span>
                </strong>
                <small>
                    <label>
                        <input type="checkbox" data-field="active" />
                        active
                    </label>
                </small>
            </header>

            <!-- CTransform (simplified) -->
            <section class="component" data-component="CTransform">
                <h4>Transform</h4>
                <form data-component-form="CTransform">
                    <div class="row">
                        <label>x <input type="number" step="0.01" data-field="position.x" /></label>
                        <label>y <input type="number" step="0.01" data-field="position.y" /></label>
                    </div>
                    <div class="row">
                        <label>vx <input type="number" step="0.01" data-field="velocity.x" /></label>
                        <label>vy <input type="number" step="0.01" data-field="velocity.y" /></label>
                    </div>
                    <div class="row">
                        <label>sx <input type="number" step="0.01" data-field="scale.x" /></label>
                        <label>sy <input type="number" step="0.01" data-field="scale.y" /></label>
                    </div>
                    <div class="row">
                        <label>rotÂ° <input type="number" step="0.1" data-field="rotation" /></label>
                    </div>
                    <div class="row">
                        <label>hSpeed <input type="number" step="0.1" data-field="hSpeed" /></label>
                        <label>vSpeed <input type="number" step="0.1" data-field="vSpeed" /></label>
                    </div>
                    <div class="row">
                        <label><input type="checkbox" data-field="grounded" /> grounded</label>
                    </div>
                    <div class="actions">
                        <button type="submit" data-action="save-component">Save</button>
                        <button type="reset">Reset</button>
                    </div>
                </form>
            </section>

            <!-- CState (simplified) -->
            <section class="component" data-component="CState">
                <h4>State</h4>
                <form data-component-form="CState">
                    <div class="row">
                        <label
                            >current
                            <input
                                type="text"
                                data-field="current"
                                placeholder="IDLE / JUMPING / WALKING.LEFT / WALKING.RIGHT"
                        /></label>
                    </div>
                    <div class="row">
                        <label>previous <input type="text" data-field="previous" /></label>
                    </div>
                    <div class="row">
                        <label><input type="checkbox" data-field="canJump" /> canJump</label>
                        <label><input type="checkbox" data-field="changeAnimation" /> changeAnimation</label>
                    </div>
                    <div class="actions">
                        <button type="submit" data-action="save-component">Save</button>
                        <button type="reset">Reset</button>
                    </div>
                </form>
            </section>
        </article>
    </li>
</template>
</file>

<file path="src/utils/events.js">
import { CustomEvents } from './enums';

// example of a custom event
const gameStopped = new CustomEvent(CustomEvents.GAME_STOPPED, {
    bubbles: true,
    cancelable: true,
});

export { gameStopped };
</file>

<file path="src/utils/texture.js">
class Texture {
    // TODO: implement the Texture class
    #image = new Image();
    #atlas = {};
    #name = '';

    constructor(name, atlas, imagePath) {
        this.#name = name;
        this.#atlas = atlas;
        this.#image.src = imagePath;
    }

    // TODO: finish implementing methods
    drawImage() {}
    getSize() {}
}

export { Texture };
</file>

<file path="src/counter.js">
export function setupCounter(element) {
  let counter = 0
  const setCounter = (count) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}
</file>

<file path="src/editor.js">
// src/editor.js
import { DockManager } from './ui/dock/dock.js';
import './ui/dock/dock.css';

const root = document.getElementById('editor');
const dock = new DockManager(root, { withRight: true });

// Put your game canvas in the center
const canvas = document.createElement('canvas');
canvas.id = 'game-canvas';
dock.centerEl.appendChild(canvas);

// Make your existing resize routine point at this canvas
// (use your DPR-aware resize from earlier)
function resizeCanvas() {
    const dpr = devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.round(rect.width * dpr));
    canvas.height = Math.max(1, Math.round(rect.height * dpr));
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Add LEFT dock panels
dock.leftTabs.addTab({
    id: 'sprites',
    title: 'Sprites',
    icon: 'ðŸ–¼ï¸',
    active: true,
    mount(root) {
        root.innerHTML = `
      <div style="padding:8px">
        <input id="spriteFilter" placeholder="Filterâ€¦" />
        <div id="spriteGrid" style="margin-top:8px; display:grid; grid-template-columns:repeat(auto-fill,72px); gap:8px;"></div>
      </div>`;
        // TODO: render sprite thumbs into #spriteGrid
    },
});

dock.leftTabs.addTab({
    id: 'tiles',
    title: 'Tiles',
    icon: 'ðŸ§±',
    mount(root) {
        root.innerHTML = `
      <div style="padding:8px; display:flex; gap:10px;">
        <canvas id="tilesetCanvas" width="256" height="256" style="border:1px solid #2a3040;border-radius:8px"></canvas>
        <div>
          <label>Brush Size</label>
          <select id="brush"><option>1Ã—1</option><option>2Ã—2</option><option>3Ã—3</option></select>
          <div style="margin-top:8px"><button id="place">Place</button> <button id="erase">Erase</button></div>
        </div>
      </div>`;
    },
});

// Add RIGHT dock panels
dock.rightTabs.addTab({
    id: 'inspector',
    title: 'Inspector',
    icon: 'ðŸ”',
    mount(root) {
        root.innerHTML = `
      <div style="padding:10px">
        <h3 style="margin:0 0 8px;">Entity</h3>
        <div id="inspectorBody" style="font:12px/1.4 system-ui;">Select somethingâ€¦</div>
      </div>`;
    },
});

dock.rightTabs.addTab({
    id: 'animations',
    title: 'Animations',
    icon: 'ðŸŽžï¸',
    mount(root) {
        root.innerHTML = `
      <div style="padding:10px">
        <button id="btnPlay">Play</button>
        <button id="btnPause">Pause</button>
        <div id="animPreview" style="height:160px;border:1px solid #2a3040;margin-top:8px;border-radius:8px;"></div>
      </div>`;
    },
});
</file>

<file path="css/style.css">
*,
*::before,
*::after {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    padding: 0;
    margin: 0;
}
body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: khaki;
}

#logging {
    display: flex;
    justify-content: space-between;
    width: 100%;
    height: 100%;
    background-color: #000;
    color: #fff;
    overflow: auto;
    padding: 10px;
    font-family: monospace;
    font-size: 12px;
}

.button-container {
    display: flex;
    justify-content: center;
    margin-top: 20px;
    padding: 20px;
}

button {
    padding: 10px 20px;
    border: none;
    cursor: pointer;
    font-size: large;
    font-weight: 600;

    &#start-btn {
        background-color: rgb(76, 222, 76);
        &:hover {
            background-color: #45a049; /* Dark green */
        }
    }

    &#change-test-btn {
        background-color: rgb(244, 3, 196);
        &:hover {
            background-color: #923f78; /* Dark green */
        }
    }
    &#end-btn {
        background-color: rgb(255, 0, 0);
        &:hover {
            background-color: rgb(187, 30, 30);
        }
        color: white;
    }

    &.red-btn {
        background-color: rgb(232, 88, 88);
        &:hover {
            background-color: rgb(201, 56, 56);
        }
        color: white;
    }

    &.small-btn {
        padding: 8px;
        font-size: small;
        font-weight: 400;
        margin: 5px;
        letter-spacing: 2px;
    }

    &.rounded-btn {
        border-radius: 50px;
    }

    &#print-level {
        border-radius: 8px;
    }
}

#canvas {
    width: 800px;
    height: 500px;

    margin: 20px;

    /* border: solid 1px black; */
    background-color: white;
}
</file>

<file path="src/action/action.js">
class Action {
    name;
    type;
    #payload = null;

    constructor(name, type) {
        this.type = type;
        this.name = name;
    }

    getName() {
        return this.name;
    }

    getType() {
        return this.type;
    }

    get lifeCycle() {
        return this.type;
    }

    set payload(data) {
        this.#payload = data;
    }

    get payload() {
        return this.#payload;
    }
}

export { Action };
</file>

<file path="src/animation/animation.js">
import { Vector } from 'vecti';
import { GameEngine } from '../gameEngine/gameEngine';

class Animation {
    // TODO: Tie the animation duration to a different factor (e.g., jumping, attacks, etc)
    // TODO: use repeat bool to end or repeat animation
    #numberOfFrames = 1;
    #currentFrame = 0;
    #duration = 8; // frames between frames
    #frameSize = new Vector(1, 1);
    #animFPS = 10;

    #name = '';
    #animationConfig;

    /**
     * @type {GameEngine}
     */
    #gameEngine;
    #frameIndex = 0;
    #simTime = 0;
    #frameTime = 0;
    #animationCompleted = false;
    onCompleteState = null;
    /**
     * Constructs a new Animation with the given name and animation config
     * @param {string} name - the name of the animation
     * @param {Object} animationConfig - an object containing the configuration for the animation
     */
    constructor(name, animationConfig, gameEngine) {
        this.#gameEngine = gameEngine;
        this.#name = name;
        this.#animationConfig = animationConfig;
        this.#animFPS = animationConfig.frameRate;
        this.#numberOfFrames = animationConfig.frames.length;
        this.#duration = animationConfig.speed;
        this.#frameTime = 1 / this.#animFPS;

        console.log(animationConfig);
    }

    // 60ps / 10ps = 6ps

    /**
     * Updates the animation by incrementing the frame index by one and
     * adjusting it according to the speed and number of frames.
     * @param {number} elapsedTime - the time delta in milliseconds
     */
    update(elapsedTime) {
        // TODO: Use the elapsed time variable in the gameLoop.onEnd function to acc
        if (this.#numberOfFrames === 1) return;
        // Guard in case another update is called once the animation is over.
        if (this.#animationCompleted) {
            console.error('INFO: An animation that has a non-repeat is called!');
            return;
        }

        this.#simTime += elapsedTime / 1000;
        while (this.#simTime >= this.#frameTime) {
            this.#simTime -= this.#frameTime;

            // If the animation does not repeat and it has exhausted all frames, we signal it is over.
            if (!this.repeats && this.#frameIndex + 2 > this.#numberOfFrames) {
                this.#animationCompleted = true;
                continue;
            }

            this.#frameIndex = (this.#frameIndex + 1) % this.#numberOfFrames;
        }
    }

    /**
     * Gets the current frame of the animation.
     *
     * @return {{frame: string, sheetId: string}} - an object containing the frame id and sheet id
     */
    getCurrentFrame() {
        return {
            frame: this.#animationConfig.frames[this.#frameIndex].frame,
            sheetId: this.#animationConfig.sheetId,
        };
    }

    hasEnded() {
        return this.#animationCompleted;
    }

    /**
     * Returns the name of the animation.
     *
     * @return {string} The name of the animation.
     */
    get name() {
        return this.#name;
    }

    get animationConfig() {
        return this.#animationConfig;
    }

    get repeats() {
        return this.#animationConfig.repeat == 1;
    }

    stop() {
        this.#animationCompleted = true;
        return this;
    }
    /**
     * Resets the animation to its initial state, setting the frame index to 0.
     */
    reset() {
        this.#frameIndex = 0;
        this.#currentFrame = 0;
        this.#animationCompleted = false;
        return this;
    }
}

export { Animation };
</file>

<file path="src/scene/scene.js">
import { Action } from '../action/action';
import { EntityManager } from '../entityManager/entityManager';
import { GameEngine } from '../gameEngine/gameEngine';
import { SceneTags } from '../utils/enums';
/**
 * @param {GameEngine} gameEngine
 *
 * @description Base class for scenes in the game
 */
class Scene extends EventTarget {
    #paused = false;

    /** @type {EntityManager} */
    entityManager = new EntityManager();

    /** @type {GameEngine} */
    gameEngine = null;
    /**
     * @description Map of action name to Action object
     * @type {Map<string, Action>}
     */
    actionMap = new Map();
    hasEnded = false;
    currentFrame = 0;
    width = 0;
    height = 0;
    tag = SceneTags.SIMPLE;

    onEnd() {
        throw new Error('Function not implemented. Child classes must implement onEnd and setPaused');
    }
    setPaused() {
        throw new Error('Function not implemented. Child classes must implement onEnd and setPaused');
    }

    /**
     * Construct a new Scene object.
     *
     * @param {GameEngine} gameEngine - the GameEngine to associate with this Scene
     */
    constructor(gameEngine, tag) {
        super();
        this.gameEngine = gameEngine;

        this.height = gameEngine.height;
        this.width = gameEngine.width;
        this.tag = tag;
    }

    /**
     * Handle an action as specified by the action map.
     *
     * @param {Action} action - the action to handle
     */
    sQueue(action) {
        throw new Error('Function not implemented. Child classes must implement onEnd and setPaused');
    }

    sRender(alpha) {
        throw new Error('Function not implemented. Child classes must implement onEnd and setPaused');
    }

    doAction(action) {
        this.sDoAction(action);
    }

    simulate(frames) {}

    registerAction(inputKey, actionName) {
        this.actionMap.set(inputKey, actionName);
    }

    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    getCurrentFrame() {
        return this.currentFrame;
    }
    hasEnded() {
        return this.hasEnded;
    }
    getActionMap() {
        return this.actionMap;
    }
    drawLine(point1, point2) {
        this.game.drawLine(point1, point2);
    }
}

export { Scene };
</file>

<file path="src/ui/tabs/createTabs.js">
import { ComponentTypes, CustomEventEnums, EntityStates, TabsEnum } from '../../utils/enums';
import { GameEngine } from '../../gameEngine/gameEngine';
import { EntityManager } from '../../entityManager/entityManager';

/**
 * Creates the default tabs for the editor.
 * @param {Tab} tab - an object with the following properties:
 *   id: string, title: string, icon?: string, tooltip?: string,
 *   closable?: boolean, badge?: string|number,
 *   mount?: (root: HTMLElement)=>void, unmount?: (root: HTMLElement)=>void,
 *   onShow?: (root: HTMLElement)=>void, onHide?: (root: HTMLElement)=>void,
 *   active?: boolean
 * @param {GameEngine} gameEngine - The game engine
 * @param {Object} payload - an object containing the EntityManager instance
 * @param {EntityManager} payload.entityManager - The entity manager instance
 * @returns {Tabs} - the created tabs instance
 */
function createTabs(tab, gameEngine, payload) {
    tab.addTab({
        id: TabsEnum.ID.ENTITIES,
        title: 'Entities',
        icon: 'ï¸ðŸ§¸',
        tooltip: 'Browse & Edit Entities',
        active: true,
        // closable: true,
        async mount(root) {
            // Entity manager
            // let entityManager = payload.entityManager;
            root.innerHTML = `
            <!-- List -->
            <ul class="entity-list" id="entityList" aria-live="polite">
                <!-- Filled dynamically -->
            </ul>`;

            gameEngine.addEventListener(CustomEventEnums.ENTITIES.UPDATED, onEntitiesUpdate);
        },
    });

    // Sprites panel
    tab.addTab({
        id: 'sprites',
        title: 'Sprites',
        icon: 'ðŸ–¼ï¸',
        tooltip: 'Browse sprites',
        active: false,
        // closable: true,

        async mount(root) {
            root.innerHTML = `
        <div class="panel-row">
            <div><label>Filter</label><input id="spriteFilter" placeholder="name"></div>
            <div><button id="clearSelection" class ="small-btn red-btn rounded-btn">Clear Selection ðŸ—‘ï¸ </button></div>
            <div id="spriteGrid" style="display:grid;grid-template-columns:repeat(auto-fill,72px);margin-top:10px;"></div>
        </div>`;

            async function loadSprites() {
                try {
                    let spriteBlob = [];
                    const sheets = gameEngine.assets.spriteSheets;
                    for (let sheetId of sheets.keys()) {
                        const sheet = sheets.get(sheetId);
                        for (let i = 0; i < sheet.frames.length; i++) {
                            const frame = sheet.frames[i].frame;
                            const osCanvas = new OffscreenCanvas(frame.w, frame.h);
                            const ctx2d = osCanvas.getContext('2d');
                            ctx2d.imageSmoothingEnabled = false;
                            const bmp = await gameEngine.spriteCache.get(
                                sheet.image,
                                frame.x,
                                frame.y,
                                frame.w,
                                frame.h,
                                'none'
                            );

                            ctx2d.drawImage(bmp, 0, 0);
                            const blob = await osCanvas.convertToBlob({ type: 'image/png' });

                            spriteBlob.push({
                                url: URL.createObjectURL(blob),
                                sheetId: sheetId,
                                sheet,
                                frame: sheet.frames[i],
                            });
                        }
                    }
                    return spriteBlob;
                } catch (e) {
                    console.error(e);
                }
            }

            const elSpriteGrid = $('#spriteGrid');
            const blobs = await loadSprites();
            for (let blob of blobs) {
                const box = document.createElement('div');
                box.style.width = '100%';
                box.style.aspectRatio = '1 / 1';
                box.style.display = 'grid';
                box.style.placeItems = 'center';
                box.style.background = 'var(--ui-bg-muted, rgba(0,0,0,.04))';
                box.style.border = '1px solid var(--ui-border, rgba(0,0,0,.12))';
                box.style.borderRadius = '6px';
                box.style.cursor = 'pointer';

                const img = new Image();
                img.src = blob.url;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.imageRendering = 'pixelated';
                img.style.objectFit = 'fill';
                img.style.objectPosition = 'center';
                img.decoding = 'async';
                img.loading = 'lazy';
                box.appendChild(img);
                elSpriteGrid.append(box);

                box.addEventListener('click', (e) => {
                    $('body').css('cursor', 'url(' + blob.url + '), auto');
                    gameEngine.dispatchEvent(
                        new CustomEvent(CustomEventEnums.SPRITE.SELECT, {
                            detail: {
                                sheetId: blob.sheetId,
                                sheet: blob.sheet,
                                frame: blob.frame,
                            },
                        })
                    );
                });
            }

            $('#clearSelection').on('click', () => {
                $('body').css('cursor', 'default');
                gameEngine.dispatchEvent(new CustomEvent(CustomEventEnums.SPRITE.CLEAR_SELECTION));
            });
        },
        onShow(root) {
            /* refresh if needed */
        },
    });

    // Animations panel
    tab.addTab({
        id: 'animations',
        title: 'Animations',
        icon: 'ðŸŽžï¸',
        tooltip: 'Browse animations',
        mount(root) {
            root.innerHTML = `
        <div>
            <button id="btnPlay">Play</button>
            <button id="btnPause">Pause</button>
            <div id="animPreview" style="height:160px;border:1px solid var(--ui-border);margin-top:8px;border-radius:8px;"></div>
        </div>`;
            // Hook your engineâ€™s preview canvas hereâ€¦
        },
    });

    tab.addTab({
        id: 'actions',
        title: 'Actions',
        icon: 'âš™ï¸',
        tooltip: 'Browse actions',
        mount(root) {
            root.innerHTML = `
        <div>
            <button id="btnPlay">Play</button>
            <button id="btnPause">Pause</button>
            <div id="animPreview" style="height:160px;border:1px solid var(--ui-border);margin-top:8px;border-radius:8px;"></div>
        </div>`;
            // Hook your engineâ€™s preview canvas here...
        },
    });

    // Tiles panel
    tab.addTab({
        id: 'tiles',
        title: 'Tiles',
        icon: 'ðŸ§±',
        badge: 0,
        tooltip: 'Tile editor',
        mount(root) {
            root.innerHTML = `<div id="tileset" style="display:flex; gap:10px;">
        <canvas id="tilesetCanvas" width="256" height="256" style="border:1px solid var(--ui-border)"></canvas>
        <div>
            <label>Brush Size</label>
            <select id="brush"><option>1Ã—1</option><option>2Ã—2</option><option>3Ã—3</option></select>
            <div style="margin-top:8px"><button id="place">Place</button> <button id="erase">Erase</button></div>
        </div>
        </div>`;
        },
    });

    // Listen to tab lifecycle if you need cross-module behavior
    tab.addEventListener('tab:select', (e) => {
        // e.detail.id -> 'sprites' | 'animations' | 'tiles'
        gameEngine.dispatchEvent(new CustomEvent(CustomEventEnums.TAB.SELECTED, { detail: e.detail }));
    });

    tab.addEventListener(CustomEventEnums.ENTITIES.UPDATED, onEntitiesUpdate);
    tab.addEventListener(CustomEventEnums.ENTITIES.UPDATED, () => console.log('updated'));
}

const onEntitiesUpdate = ({ detail }) => {
    const elList = $('<div></div>');
    detail.entities.forEach((entity) => {
        const tr = entity.getComponent(ComponentTypes.CTransform);
        const st = entity.getComponent(ComponentTypes.CState);

        let elState = undefined;
        if (st) {
            let stOptions = '';
            for (let option of Object.values(EntityStates)) {
                stOptions += `<option value="${option}">${option}</option>`;
            }
            elState = `
                        <!-- CState (simplified) -->
                        <details class="component" data-component="CState">
                            <h4>State</h4>
                            <form data-component-form="CState">
                                <div class="row">
                                    <label>current
                                    <select data-field="current">
                                    ${stOptions}
                                    </select>
                                    </label>
                                </div>
                                <div class="row">
                                    <label>previous <input type="text" data-field="previous" value="${st.previous} /> </label>
                                </div>
                                <div class="row">
                                    <label><input type="checkbox" data-field="canJump" checked="${st.canJump}" /> canJump</label>
                                </div>
                            </form>
                        </details>
                    `;
        }

        let elEntity = `
        <li class="entity-card" data-entity-id="${entity.id}">
                    <article>
                        <header class='entity-header'>
                            <strong>
                                <span data-entity-tag>${entity.tag}</span>
                                <span>(entity id#<span data-entity-id> ${entity.id})</span></span>
                            </strong>
                            <small>
                                <label>
                                    <input type="checkbox" data-field="active" checked="${entity.isActive()}" />
                                </label>
                            </small>
                        </header>

                        <!-- CTransform (simplified) -->
                        <details class="component" data-component="CTransform">
                            <h4>Transform</h4>
                            <form data-component-form="CTransform">
                                <div class="row">
                                        <label>x <input class="hidden" type="number" step="0.01" data-field="position.x" value="${
                                            tr.position.x
                                        }" /></label>
                                        <label>y <input class="hidden" type="number" step="0.01" data-field="position.y" value="${
                                            tr.position.y
                                        }" /></label>
                                        <label>vx <input class="hidden" type="number" step="0.01" data-field="velocity.x" value="${
                                            tr.velocity.x
                                        }" /></label>
                                        <label>vy <input class="hidden" type="number" step="0.01" data-field="velocity.y" value="${
                                            tr.velocity.y
                                        }" /></label>
                                </div>
                                <div class="row">
                                    <label>sx <input class="hidden" type="number" step="0.01" data-field="scale.x" value="${
                                        tr.scale.x
                                    }" /></label>
                                    <label>sy <input class="hidden" type="number" step="0.01" data-field="scale.y" value="${
                                        tr.scale.y
                                    }" /></label>
                                    <label>rotÂ° <input class="hidden" type="number" step="0.1" data-field="rotation" value="${
                                        tr.angle
                                    }"  /></label>
                                    <label>grounded<input class="hidden" type="checkbox" data-field="grounded" checked="${
                                        tr.grounded
                                    }" /> </label>
                                </div>
                            </div>
                            </form>
                        </details>

                        ${st ? elState : ''}

                        <menu>
                                <div class="actions">
                                    <li><button type="submit" data-action="save-component">Save</button></li>
                                    <li><button type="submit" data-action="refresh-component">Refresh</button></li>
                                    <li><button type="submit" data-action="delete-component"><i class="iconoir-xmark-circle-solid text-red icon-large"></i></button></li>
                                </div>
                        </menu>
                    </article>
                    </li>`;

        elList.append(elEntity);
    });
    $('#entityList').html(elList);
};

export { createTabs };
</file>

<file path="src/ui/tabs/tabs.base.css">
/* tabs.base.css */
.tab-container {
    font-family: system-ui, Segoe UI, Roboto, sans-serif;
    color: var(--ui-text);
    background: var(--ui-surface);
    border: var(--ui-border-width, 1px) solid var(--ui-border);
    border-radius: var(--ui-radius, 8px);
    box-shadow: var(--ui-shadow, none);
    overflow: hidden;
    cursor: grab;
    min-width: 400px;
    min-height: 500px;
    max-width: 480px;
}

.tab-container.ui-draggable-dragging {
    cursor: grabbing;
}

/* header strip / title */
.tab-container::before {
    content: attr(data-title);
    display: block;
    padding: var(--hdr-pad, 8px 12px);
    background: var(--hdr-bg, transparent);
    color: var(--hdr-fg, var(--ui-text));
    border-bottom: var(--hdr-border, 1px solid var(--ui-border));
    font: var(--hdr-font, 600 12px/1 system-ui, sans-serif);
    letter-spacing: var(--hdr-tracking, 0.04em);
    text-transform: var(--hdr-transform, uppercase);
}

/* tabs row */
.tabs {
    display: flex;
    gap: var(--tab-gap, 4px);
    padding: var(--tab-pad, 6px);
    background: var(--tabs-bg, var(--ui-surface-2, var(--ui-surface)));
    border-bottom: var(--tabs-border, 1px solid var(--ui-border));
    overflow-x: auto;
    /* max-width: 100%; */
}

/* tab button */
.tab-links {
    appearance: none;
    cursor: pointer;
    white-space: nowrap;
    background: var(--tab-bg, transparent);
    color: var(--tab-fg, var(--ui-muted));
    border: var(--tab-border, 1px solid transparent);
    border-radius: var(--tab-radius, 6px 6px 0 0);
    padding: var(--tab-btn-pad, 8px 12px);
    font: var(--tab-font, 500 13px/1 system-ui, sans-serif);
    box-shadow: var(--tab-shadow, none);
}
.tab-links:hover {
    background: var(--tab-hover-bg, rgba(255, 255, 255, 0.05));
    color: var(--ui-text);
}
.tab-links:focus-visible {
    outline: var(--focus-outline, 2px solid var(--ui-accent));
    outline-offset: var(--focus-offset, 2px);
}

.tab-links.active {
    background: var(--tab-active-bg, var(--ui-surface));
    color: var(--ui-text);
    border: var(--tab-active-border, 1px solid var(--ui-border));
    box-shadow: var(--tab-active-shadow, none);
    position: relative;
}
.tab-links.active::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    height: var(--tab-accent-h, 0);
    background: var(--ui-accent);
    border-radius: var(--tab-accent-radius, 0);
}

/* panels */
.tab-content {
    display: none;
    background: var(--panel-bg, var(--ui-bg, var(--ui-surface)));
    padding: var(--panel-pad, 16px);
    max-height: 400px;
    overflow: auto;
}
.tab-content.active {
    display: block;
}

/* small bits */
.tab-title {
    pointer-events: none;
}
.tab-icon {
    margin-right: 6px;
}
</file>

<file path="src/utils/sprite.js">
import { Vector } from 'vecti';
import { ScalePolicies } from './enums';

/**
 * Calculate the scaled size of a sprite given its trimmed opaque bounds,
 * user scale factors, and a policy for handling aspect ratio.
 *
 * @param {Object} tr - Trimmed opaque bounds of the sprite {w, h}
 * @param {Object} scale - User scale factors {x, y}
 * @param {string} policy - Aspect ratio policy
 *     - none: scale each axis independently
 *     - uniformX: scale by X only, preserving aspect
 *     - uniformY: scale by Y only, preserving aspect
 *     - fit: fit the sprite inside the targetBox, preserving aspect
 *     - cover: cover the targetBox, preserving aspect
 * @param {Vector} targetBox - Target box {x, y} for fit and cover policies
 * @returns {Vector} Scaled size of the sprite {x, y}
 */
function getScaledSpriteSize(tr, scale, policy = 'uniformX', targetBox) {
    // tr: {w, h} from trimmedRect (opaque bounds)
    // scale: {x, y} user scale (sign only used for flipping)
    const sx = Math.abs(scale.x ?? 1);
    const sy = Math.abs(scale.y ?? 1);
    // const ar = tr.w > 0 && tr.h > 0 ? tr.w / tr.h : 1; // aspect ratio

    switch (policy) {
        case ScalePolicies.NONE: {
            // No aspect lock: scale each axis independently.
            return new Vector(tr.x * sx, tr.y * sy);
        }
        case ScalePolicies.UNIFORM_X: {
            // Drive by X only; preserve aspect.
            const k = sx;
            return new Vector(tr.x * k, tr.y * k);
        }
        case ScalePolicies.UNIFORM_Y: {
            // Drive by Y only; preserve aspect.
            const k = sy;
            return new Vector(tr.x * k, tr.y * k);
        }
        case ScalePolicies.FIT: {
            // Fit inside targetBox {x,y}, preserving aspect
            const k = Math.min(targetBox.x / tr.x, targetBox.y / tr.y);
            return new Vector(tr.x * k, tr.y * k);
        }
        case ScalePolicies.COVER: {
            // Cover targetBox {x,y}, preserving aspect
            const k = Math.max(targetBox.x / tr.x, targetBox.x / tr.x);
            return new Vector(tr.x * k, tr.y * k);
        }
        default: {
            // default = uniform by X
            const k = sx;
            return new Vector(tr.x * k, tr.h * k); // { w: tr.w * k, h: tr.h * k };
        }
    }
}

/**
 * Position & scale a trimmed sprite inside its scaled logical box.
 *
 * @param {Vector} trimmed        opaque bounds size (w,h) -> {x,y}
 * @param {Vector} logicalSize    original full size incl. padding (w,h) -> {x,y}
 * @param {Vector} scale          user scale (sign only for flipping) -> {x,y}
 * @param {ScalePolicies} policy  NONE | UNIFORM_X | UNIFORM_Y | FIT | COVER
 * @param {Vector} logicalPos     top-left of the *scaled* logical box in world space
 * @param {Vector} [targetBox]    required for FIT/COVER -> {x,y}
 * @param {Vector} [trimOffset]   unscaled offset of trimmed rect inside logical (top-left) -> {x,y}
 * @returns {{
 *   drawSize: Vector,                  // scaled size of trimmed rect
 *   logicalSizeScaled: Vector,         // scaled size of logical/original rect
 *   trimmedTopLeft: Vector,            // top-left to draw the trimmed rect in world space
 * trimmedCenter: Vector,
 *   kx: number, ky: number
 * }}
 */
function getScaledSpriteLayout(
    trimmed,
    logicalSize,
    scale,
    policy = ScalePolicies.UNIFORM_X,
    logicalPos,
    targetBox,
    trimOffset = new Vector(0, 0)
) {
    // Scale sizes using your existing helper (keeps policies consistent)
    const drawSize = getScaledSpriteSize(trimmed, scale, policy, targetBox);
    const logicalSizeScaled = getScaledSpriteSize(logicalSize, scale, policy, targetBox);

    // Final multipliers applied to logical space
    const kx = logicalSizeScaled.x / (logicalSize.x || 1);
    const ky = logicalSizeScaled.y / (logicalSize.y || 1);

    // If a real trim offset is available, use it; otherwise center the trimmed rect
    const hasRealOffset = trimOffset.x !== 0 || trimOffset.y !== 0;
    const logicalCenter = new Vector(logicalPos.x + logicalSizeScaled.x / 2, logicalPos.y + logicalSizeScaled.y / 2);

    const trimmedCenter = hasRealOffset
        ? new Vector(logicalPos.x - trimOffset.x * kx, logicalPos.y + trimOffset.y * ky)
        : new Vector(logicalPos.x - logicalSizeScaled.x / 2, logicalPos.y - logicalSizeScaled.y / 2);

    const trimmedTopLeft = hasRealOffset
        ? new Vector(logicalPos.x - trimOffset.x * kx, logicalPos.y + trimOffset.y * ky)
        : new Vector(
              logicalPos.x - (logicalSizeScaled.x - drawSize.x) / 2,
              logicalPos.y - (logicalSizeScaled.y - drawSize.y) / 2
          );
    return { drawSize, logicalSizeScaled, trimmedTopLeft, trimmedCenter, kx, ky };
}
export { getScaledSpriteSize, getScaledSpriteLayout };
</file>

<file path="src/utils/spriteCacheGPU.js">
// flippedCacheGpu.js
// GPU-friendly cache for pre-rendered sprite frames (normal + flipped).
// Stores ImageBitmaps (when supported) for fast, predictable draws.
//
// API:
//   const cache = new FlipCacheGPU(64 * 1024 * 1024); // 64MB budget
//   await cache.prewarm(image, framesArray, 'none');  // frames: [{sx,sy,sw,sh}, ...]
//   await cache.prewarm(image, framesArray, 'flipX'); // flipped variant
//   const bmp = await cache.get(image, sx, sy, sw, sh, 'flipX'); // use in drawImage
//
// Notes:
// - Byte accounting is heuristic: sw * sh * 4 (RGBA).
// - If createImageBitmap is unavailable, falls back to HTMLCanvasElement.
// - LRU eviction keeps memory bounded; oldest entries drop first.
// - Concurrent requests for the same key are coalesced (single build).

export class SpriteCacheGPU {
    /**
     * @param {number} maxBytes Approximate memory budget for cached frames (bytes).
     */
    constructor(maxBytes = 64 * 1024 * 1024) {
        this.maxBytes = maxBytes;
        this.bytes = 0;
        this.map = new Map(); // key -> { bmp, w, h, bytes }
        this.inflight = new Map(); // key -> Promise<bitmap>
    }

    /**
     * Build and cache a list of frames for one mode.
     * @param {CanvasImageSource} image  Source spritesheet image (HTMLImageElement/HTMLCanvasElement/OffscreenCanvas)
     * @param {{sx:number,sy:number,sw:number,sh:number}[]} frames
     * @param {'none'|'flipX'} mode
     */
    async prewarm(image, frames, mode = 'none') {
        for (const f of frames) {
            await this.#ensure(image, f.sx, f.sy, f.sw, f.sh, mode);
        }
    }

    /**
     * Get a cached bitmap for the given source rect + mode; build if missing.
     * @returns {Promise<ImageBitmap|HTMLCanvasElement>}
     */
    async get(image, sx, sy, sw, sh, mode = 'none') {
        const key = this.#key(image, sx, sy, sw, sh, mode);
        const hit = this.map.get(key);
        if (hit) {
            // LRU bump
            this.map.delete(key);
            this.map.set(key, hit);
            return hit.bmp;
        }
        // Coalesce concurrent builds
        if (this.inflight.has(key)) return this.inflight.get(key);

        const p = (async () => {
            const bmp = await this.#make(image, sx, sy, sw, sh, mode);
            this.#insert(key, { bmp, w: sw, h: sh, bytes: sw * sh * 4 });
            return bmp;
        })();

        this.inflight.set(key, p);
        try {
            const bmp = await p;
            return bmp;
        } finally {
            this.inflight.delete(key);
        }
    }

    /** Clear all cached entries and free resources where possible. */
    clear() {
        for (const { bmp } of this.map.values()) {
            try {
                bmp.close?.();
            } catch {}
        }
        this.map.clear();
        this.bytes = 0;
        // Reject/ignore inflight callers gracefully on next await, if any were left.
        this.inflight.clear();
    }

    // ---------------- internal helpers ----------------

    async #ensure(image, sx, sy, sw, sh, mode) {
        const key = this.#key(image, sx, sy, sw, sh, mode);
        if (this.map.has(key)) return;
        if (this.inflight.has(key)) {
            await this.inflight.get(key);
            return;
        }

        const p = (async () => {
            const bmp = await this.#make(image, sx, sy, sw, sh, mode);
            this.#insert(key, { bmp, w: sw, h: sh, bytes: sw * sh * 4 });
            return bmp;
        })();

        this.inflight.set(key, p);
        try {
            await p;
        } finally {
            this.inflight.delete(key);
        }
    }

    #key(image, sx, sy, sw, sh, mode) {
        // Prefer URL; otherwise attach a stable object id on first use.
        const srcId = image?.src || image?._id || (image._id = `img@${Math.random().toString(36).slice(2)}`);
        return `${srcId}|${sx},${sy},${sw},${sh}|${mode}`;
    }

    async #make(image, sx, sy, sw, sh, mode) {
        const hasOffscreen = typeof OffscreenCanvas !== 'undefined';
        const off = hasOffscreen
            ? new OffscreenCanvas(sw, sh)
            : Object.assign(document.createElement('canvas'), { width: sw, height: sh });
        const ctx = off.getContext('2d');
        // Pixel art friendly; harmless for HD art.
        ctx.imageSmoothingEnabled = false;

        if (mode === 'flipX') {
            ctx.translate(sw, 0);
            ctx.scale(-1, 1);
        }
        // Draw the frame sub-rect into (0,0)-(sw,sh)
        ctx.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);

        // Promote to ImageBitmap if available (usually GPU-backed & fast to draw).
        if (typeof createImageBitmap === 'function') {
            return await createImageBitmap(off);
        }
        // Fallback: return the canvas itself.
        return off;
    }

    #insert(key, entry) {
        // Evict oldest until within budget
        while (this.bytes + entry.bytes > this.maxBytes && this.map.size) {
            const [oldKey, old] = this.map.entries().next().value;
            this.map.delete(oldKey);
            this.bytes -= old.bytes || 0;
            try {
                old.bmp.close?.();
            } catch {}
        }
        this.map.set(key, entry);
        this.bytes += entry.bytes;
    }
}

function human(bytes) {
    return bytes < 1024
        ? `${bytes} B`
        : bytes < 1024 * 1024
        ? `${(bytes / 1024).toFixed(1)} KB`
        : `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}

function printSpriteCacheStats(cache) {
    const byMode = new Map(); // mode -> {count, bytes}
    const bySheet = new Map(); // sheetId/url -> {count, bytes}

    for (const [key, entry] of cache.map.entries()) {
        // key format: `${srcId}|${sx},${sy},${sw},${sh}|${mode}`
        const [srcAndRect, mode] =
            key.split('|flipX').length > 1 ? [key.replace(/\|flipX$/, ''), 'flipX'] : key.split(/\|(none|flipX)$/); // works with both 'none' and 'flipX'
        const srcId = srcAndRect.split('|')[0];

        const m = byMode.get(mode) || { count: 0, bytes: 0 };
        m.count++;
        m.bytes += entry.bytes;
        byMode.set(mode, m);

        const s = bySheet.get(srcId) || { count: 0, bytes: 0 };
        s.count++;
        s.bytes += entry.bytes;
        bySheet.set(srcId, s);
    }

    let total = 0;
    for (const v of byMode.values()) total += v.bytes;

    console.groupCollapsed('SpriteCache Stats');
    console.info('Total:', human(total), `(entries: ${cache.map.size})`);
    console.group('By mode');
    for (const [mode, v] of byMode.entries()) {
        console.info(`  ${mode}: ${human(v.bytes)} (${v.count} frames)`);
    }
    console.groupEnd();
    console.group('By sheet');
    for (const [sheet, v] of bySheet.entries()) {
        console.info(`  ${sheet}: ${human(v.bytes)} (${v.count} frames)`);
    }
    console.groupEnd();
    console.groupEnd();
}

export { printSpriteCacheStats };
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Ignore the repomix files
repomix-output.xml
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Tlatoonie</title>
        <link rel="stylesheet" href="./css/style.css" />
        <link rel="stylesheet" href="./src/ui/buttons/entityList/entity.base.css" />
        <link rel="stylesheet" href="./src/ui/tabs/tabs.base.css" />
        <link rel="stylesheet" href="./src/ui/tabs/theme-win95.css" />
        <link rel="stylesheet" href="./src/ui/tabs/theme-mac9.css" />
        <link rel="stylesheet" href="./src/ui/tabs/theme-crt.css" />
        <link rel="stylesheet" href="./src/ui/tabs/theme-synthwave.css" />
        <link rel="stylesheet" href="./src/ui/tabs/theme-light.css" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/iconoir-icons/iconoir@main/css/iconoir.css" />
    </head>

    <body>
        <div id="logging">
            <div class="stats">
                <h1>Logging</h1>
                <menu>
                    <li>
                        FPS(seconds):
                        <div id="fps"></div>
                    </li>
                    <li>
                        Fixed Delta(seconds):
                        <div id="fixed"></div>
                    </li>
                    <li>
                        Elapsed Time(seconds):
                        <div id="elapsed"></div>
                    </li>
                    <li>
                        Simulated Time(seconds):
                        <div id="simTime"></div>
                    </li>
                    <li>
                        Number of Ticks(seconds):
                        <div id="ticks"></div>
                    </li>
                </menu>
            </div>
            <div class="controls">
                <menu>
                    <li><button id="print-scene" class="small-btn">print scene json</button></li>
                </menu>
            </div>
        </div>

        <canvas id="canvas"> Your browser does not support the canvas element. </canvas>
        <div class="game-debug">
            <h1></h1>
            <menu></menu>
        </div>
        <div id="tab-theme-root" data-theme="mac9">
            <div class="tab-container" id="tab-container" data-title="Panels"></div>
        </div>

        <!-- index.html (relevant part) -->
        <script type="module" src="/src/main.js"></script>
        <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
        <script src="https://code.jquery.com/ui/1.14.1/jquery-ui.js"></script>
    </body>
</html>
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite';

export default defineConfig({
    base: '/tlatoonie-scenes/',
});
</file>

<file path="src/utils/enums.js">
/**
 * Enum for component types.
 * @enum {string}
 * @readonly
 */
const ComponentTypes = Object.freeze({
    CAnimation: 'COMPONENT_TYPE_ANIMATION',
    CAttacks: 'COMPONENT_TYPE_ATTACK',
    CBoundingBox: 'COMPONENT_TYPE_BOUNDING_BOX',
    CGravity: 'COMPONENT_TYPE_GRAVITY',
    CInput: 'COMPONENT_TYPE_INPUT',
    CInterpolation: 'COMPONENT_TYPE_INTERPOLATION',
    CLifespan: 'COMPONENT_TYPE_LIFESPAN',
    CScore: 'COMPONENT_TYPE_SCORE',
    CShape: 'COMPONENT_TYPE_SHAPE',
    CState: 'COMPONENT_TYPE_STATE',
    CTransform: 'COMPONENT_TYPE_TRANSFORM',
    CSpriteDimensions: 'COMPONENT_TYPE_SPRITE_DIMENSIONS',
    /** @description The sprite component */
    CSprite: 'COMPONENT_TYPE_SPRITE',
    /** @description Used to store entity flags @see {EntityFlags}  */
    CFlags: 'COMPONENT_TYPE_FLAGS',
    CTraits: 'COMPONENT_TYPE_TRAITS',
    CCollision: 'COMPONENT_TYPE_Collision',
});

/**
 * The player can be in one or more of these state at any time
 *
 * @enum {string}
 * @see {@link }
 * @readonly
 */
const EntityStates = Object.freeze({
    JUMPING: 'ENTITY_STATE_JUMPING',
    ON_GROUND: 'ENTITY_STATE_ON_GROUND',
    WALKING_LEFT: 'ENTITY_STATE_WALKING:LEFT',
    WALKING_RIGHT: 'ENTITY_STATE_WALKING:RIGHT',
    WALKING: 'ENTITY_STATE_WALKING',
    RUNNING: 'ENTITY_STATE_RUNNING',
    HURT: 'ENTITY_STATE_HURT',
    DEFEND: 'ENTITY_STATE_DEFEND',
    FALLING: 'ENTITY_STATE_FALLING',
    TAKING_DAMAGE: 'ENTITY_STATE_TAKING_DAMAGE',
    IDLE: 'ENTITY_STATE_IDLE',
    IDLE_LEFT: 'ENTITY_STATE_IDLE_LEFT',
    IDLE_RIGHT: 'ENTITY_STATE_IDLE_RIGHT',
    ATTACKING_ONE: 'ENTITY_STATE_ATTACKING:ONE',
    ATTACKING_TWO: 'ENTITY_STATE_ATTACKING:TWO',
    ATTACKING: 'ENTITY_STATE_ATTACKING',
});

/**
 * The player attacks
 *
 * @enum {string}
 * @see {@link }
 * @readonly
 */
const PlayerAttacks = Object.freeze({
    ATTACK_ONE: 'PLAYER_ATTACK_ONE',
    ATTACK_TWO: 'PLAYER_ATTACK_TWO',
});

/**
 * Available types of entities
 *
 * @enum {string}
 * @see {@link EntityManager}
 * @readonly
 */
const EntityTypes = Object.freeze({
    PLAYER: 'ENTITY_TYPE_PLAYER',
    NPC: 'ENTITY_TYPE_NPC',
    TILE: 'ENTITY_TYPE_TILE',
    GROUND: 'ENTITY_TYPE_GROUND',
});

/**
 * Scale policies
 * @enum {string}
 * @see {@link 'Sprite'}
 * @readonly
 */
const ScalePolicies = Object.freeze({
    FREE: 'SCALE_POLICIES_FREE',
    UNIFORM_X: 'SCALE_POLICIES_UNIFORM_X',
    UNIFORM_Y: 'SCALE_POLICIES_UNIFORM_Y',
    FIT: 'SCALE_POLICIES_FIT',
    COVER: 'SCALE_POLICIES_COVER',
    NONE: 'SCALE_POLICIES_NONE',
});

/**
 * Enum for interpolation types.
 * @enum {string}
 * @readonly
 */
const Interpolations = Object.freeze({
    EASEIN_EXPO: 'INTERPOLATION_EASEIN_EXPO',
    EASEIN_SINE: 'INTERPOLATION_EASEIN_SINE',
    EASEINOUT_EXPO: 'INTERPOLATION_EASEINOUT_EXPO',
    EASEINOUT_SINE: 'INTERPOLATION_EASEINOUT_SINE',
    EASEINOUT_ELASTIC: 'INTERPOLATION_EASEINOUT_ELASTIC',
    EASEIN_ELASTIC: 'INTERPOLATION_EASEIN_ELASTIC',
    EASEOUT_ELASTIC: 'INTERPOLATION_EASEOUT_ELASTIC',
    EASEOUT_SINE: 'INTERPOLATION_EASEOUT_SINE',
});

/**
 * Enum for the ui tab ids
 * @enum {string}
 * @readonly
 */
const TabsEnum = Object.freeze({
    ID: {
        SPRITES: 'TABS:ID_SPRITES',
        ENTITIES: 'TABS:ID_ENTITIES',
    },
});

/**
 * Enum for scene names.
 * @enum {string}
 * @readonly
 */
const SceneTags = Object.freeze({
    MENU: 'SCENE_NAME_MENU',
    PLAY: 'SCENE_NAME_PLAY',
    SIMPLE: 'SIMPLE',
});

/**
 * Enum for custom events.
 * @enum {string}
 * @readonly
 */
const CustomEventEnums = Object.freeze({
    GAME_STOPPED: 'CUSTOM_EVENT_GAME_STOPPED',
    GAME_RESUMED: 'CUSTOM_EVENT_GAME_RESUMED',
    GAME_ENDED: 'CUSTOM_EVENT_GAME_ENDED',
    GAME_STARTED: 'CUSTOM_EVENT_GAME_STARTED',
    MOUSE_DOWN: 'CUSTOM_EVENT_MOUSE_DOWN',
    MOUSE_UP: 'CUSTOM_EVENT_MOUSE_UP',
    KEY_DOWN: 'CUSTOM_EVENT_KEY_DOWN',
    KEY_UP: 'CUSTOM_EVENT_KEY_UP',
    ACTION_START: 'CUSTOM_EVENT_ACTION_START',
    ACTION_END: 'CUSTOM_EVENT_ACTION_END',
    POINTER_DOWN: 'CUSTOM_EVENT_POINTER_DOWN',
    POINTER_UP: 'CUSTOM_EVENT_POINTER_UP',
    POINTER_MOVE: 'CUSTOM_EVENT_POINTER_MOVE',
    WINDOW_RESIZED: 'CUSTOM_EVENT_WINDOW_RESIZED',
    SPRITE: {
        SELECT: 'CUSTOM_EVENT_SPRITE:SELECT',
        DELETE: 'CUSTOM_EVENT_SPRITE:DELETE',
        CLEAR_SELECTION: 'CUSTOM_EVENT_SPRITE:CLEAR_SELECTION',
    },
    ENTITIES: {
        UPDATED: 'CUSTOM_EVENT_ENTITIES:UPDATED',
    },
    TAB: {
        SELECTED: 'CUSTOM_EVENT_TAB:SELECTED',
    },
});

/**
 * Enum for action types.
 * @enum {string}
 * @readonly
 */
const ActionEnums = Object.freeze({
    PAUSE: 'ACTION_ENUM_PAUSE',
    QUIT: 'ACTION_ENUM_QUIT',
    TOGGLE_TEXTURE: 'ACTION_ENUM_TOGGLE_TEXTURE',
    TOGGLE_COLLISION: 'ACTION_ENUM_TOGGLE_COLLISION',
    TOGGLE_GRID: 'ACTION_ENUM_TOGGLE_GRID',
    RIGHT: 'ACTION_ENUM_RIGHT',
    LEFT: 'ACTION_ENUM_LEFT',
    UP: 'ACTION_ENUM_UP',
    DOWN: 'ACTION_ENUM_DOWN',
    CLICK: 'ACTION_ENUM_CLICK',
    PRESS: 'ACTION_ENUM_PRESS',
    RELEASE: 'ACTION_ENUM_RELEASE',
    GRAB: 'ACTION_ENUM_GRAB',
    RELEASE_GRAB: 'ACTION_ENUM_RELEASE_GRAB',
    POINTER_POSITION: 'ACTION_ENUM_POINTER_POSITION',
    JUMP: 'ACTION_ENUM_JUMP',
    FALL: 'ACTION_ENUM_FALL',
    ON_GROUND: 'ACTION_ENUM_ON_GROUND',
    ATTACK: 'ACTION_ENUM_ATTACK',
});

/**
 * Enum for entity flags.
 * @enum {number}
 * @readonly
 */
const EntityFlags = Object.freeze({
    STATIC: 1 << 0, // doesn't move (e.g., walls)
    DECORATION: 1 << 1, // visual only
    COLLIDES: 1 << 2, // participates in collision tests
    TRIGGER: 1 << 3, // overlaps but no physical response
    INTERACTIVE: 1 << 4, // can be clicked/used
    AI: 1 << 5, // has AI logic
    PLAYER: 1 << 6, // player-owned/controlled
    ENEMY: 1 << 7, // enemy faction
    ANIMATED: 1 << 8, // the entity has animation/s
    CAN_DIE: 1 << 9, // can die and be deleted from the game
    CAN_FALL: 1 << 10, // the entity can fall
});

/**
 * Human readable flags/traits
 * @enum {string}
 * @readonly
 */
const EntityTraits = Object.freeze({
    STATIC: 'ENTITY_TRAIT_STATIC', // doesn't move (e.g., walls)
    DECORATION: 'ENTITY_TRAIT_DECORATION', // visual only
    COLLIDES: 'ENTITY_TRAIT_COLLIDES', // participates in collision tests
    TRIGGER: 'ENTITY_TRAIT_TRIGGER', // overlaps but no physical response
    INTERACTIVE: 'ENTITY_TRAIT_INTERACTIVE', // can be clicked/used
    AI: 'ENTITY_TRAIT_AI', // has AI logic
    PLAYER: 'ENTITY_TRAIT_PLAYER', // player-owned/controlled
    ENEMY: 'ENTITY_TRAIT_ENEMY', // enemy faction
    ANIMATED: 'ENTITY_TRAIT_ANIMATED', // has animation/s
    CAN_DIE: 'ENTITY_TRAIT_CAN_DIE', // can die and be deleted from the game
});

/**
 * Enum for action keys.
 * @enum {string}
 * @readonly
 */
const KeyCodes = Object.freeze({
    // Letters (lowercase)
    a: 'a',
    b: 'b',
    c: 'c',
    d: 'd',
    e: 'e',
    f: 'f',
    g: 'g',
    h: 'h',
    i: 'i',
    j: 'j',
    k: 'k',
    l: 'l',
    m: 'm',
    n: 'n',
    o: 'o',
    p: 'p',
    q: 'q',
    r: 'r',
    s: 's',
    t: 't',
    u: 'u',
    v: 'v',
    w: 'w',
    x: 'x',
    y: 'y',
    z: 'z',

    // Letters (uppercase)
    A: 'A',
    B: 'B',
    C: 'C',
    D: 'D',
    E: 'E',
    F: 'F',
    G: 'G',
    H: 'H',
    I: 'I',
    J: 'J',
    K: 'K',
    L: 'L',
    M: 'M',
    N: 'N',
    O: 'O',
    P: 'P',
    Q: 'Q',
    R: 'R',
    S: 'S',
    T: 'T',
    U: 'U',
    V: 'V',
    W: 'W',
    X: 'X',
    Y: 'Y',
    Z: 'Z',

    // Digits (top row)
    num_0: '0',
    num_1: '1',
    num_2: '2',
    num_3: '3',
    num_4: '4',
    num_5: '5',
    num_6: '6',
    num_7: '7',
    num_8: '8',
    num_9: '9',

    // Arrows
    ArrowUp: 'ArrowUp',
    ArrowDown: 'ArrowDown',
    ArrowLeft: 'ArrowLeft',
    ArrowRight: 'ArrowRight',

    // Controls / modifiers
    space: 'space',
    enter: 'enter',
    escape: 'escape',
    tab: 'tab',
    backspace: 'backspace',
    shift: 'shift',
    control: 'control',
    alt: 'alt',
    meta: 'meta', // meta = Cmd on Mac, Win on Windows
    capslock: 'capslock',
    contextmenu: 'contextmenu',

    // Navigation / editing
    insert: 'insert',
    delete: 'delete',
    home: 'home',
    end: 'end',
    pageup: 'pageup',
    pagedown: 'pagedown',

    // Function keys
    F1: 'F1',
    F2: 'F2',
    F3: 'F3',
    F4: 'F4',
    F5: 'F5',
    F6: 'F6',
    F7: 'F7',
    F8: 'F8',
    F9: 'F9',
    F10: 'F10',
    F11: 'F11',
    F12: 'F12',

    // Numpad (treat as logical actions; actual KeyboardEvent.key may vary)
    numpad0: 'numpad0',
    numpad1: 'numpad1',
    numpad2: 'numpad2',
    numpad3: 'numpad3',
    numpad4: 'numpad4',
    numpad5: 'numpad5',
    numpad6: 'numpad6',
    numpad7: 'numpad7',
    numpad8: 'numpad8',
    numpad9: 'numpad9',
    numpadAdd: 'numpadAdd',
    numpadSubtract: 'numpadSubtract',
    numpadMultiply: 'numpadMultiply',
    numpadDivide: 'numpadDivide',
    numpadDecimal: 'numpadDecimal',
    numpadEnter: 'numpadEnter',

    // Common punctuation (friendly names)
    minus: 'minus',
    equal: 'equal',
    bracketLeft: 'bracketLeft',
    bracketRight: 'bracketRight',
    backslash: 'backslash',
    semicolon: 'semicolon',
    quote: 'quote',
    comma: 'comma',
    period: 'period',
    slash: 'slash',
    backquote: 'backquote',
    pointerDown: 'mouseDown',
    pointerUp: 'mouseUp',
    pointerMove: 'mouseMove',
});

/**
 * Enum for action types.
 * @enum {string}
 * @readonly
 */
const ActionLifeCycle = Object.freeze({
    START: 'ACTION_TYPE_START',
    END: 'ACTION_TYPE_END',
    MOUSE: 'ACTION_TYPE_MOUSE',
});

/**
 * @enum {string}
 * @readonly
 */
const ActionKeys = Object.freeze({ ...KeyCodes, MISC_MANUAL: 'MISC_MANUAL_KEY_ACTION' });

export {
    Interpolations,
    ComponentTypes,
    SceneTags,
    CustomEventEnums,
    ActionEnums,
    ActionKeys,
    KeyCodes,
    ActionLifeCycle,
    ScalePolicies,
    EntityTypes,
    EntityStates,
    EntityFlags,
    EntityTraits,
    TabsEnum,
    PlayerAttacks,
};
</file>

<file path="src/utils/file.js">
/**
 * Loads a JSON file from the given URL asynchronously.
 *
 * @param {string} url URL of the JSON file to load.
 *
 * @returns {Promise<Object>} A Promise that resolves with the loaded JSON data.
 *
 * @throws {Error} If the fetch request fails, or if the response status is not OK.
 */
async function loadJSON(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        return data;
    } catch (err) {
        console.error('(loadJSON)Error loading JSON: ', err);
    }
}

/**
 * Waits for all images on the page to finish loading asynchronously.
 *
 * @returns {Promise<void>} A Promise that resolves when all images have finished loading.
 */
async function resolveImages() {
    // console.log('loading images: ', document.images);

    await Promise.all(
        Array.from(document.images).map((image) => {
            return new Promise((resolve) => {
                if (image.complete) {
                    // Already loaded (cached)
                    resolve();
                } else {
                    image.addEventListener('load', resolve);
                    image.addEventListener('error', resolve); // prevent hanging forever
                }
            });
        })
    );

    console.log('all images loaded');
}

async function resolveConfiguration(configJsonPath) {
    //TODO : use a the function buildMaskAndTrimmedBounds to get the trimmedRect and create a cli option https://chatgpt.com/c/68bdd016-fe00-832f-8907-915b800dfd3b
    try {
        const data = await loadJSON(configJsonPath);
        const animationMap = new Map();
        const spriteSheetMap = new Map();
        const levelData = {};

        const assets = {
            animations: animationMap,
            spriteSheets: spriteSheetMap,
            images: [],
            levelData,
            // fonts: fontMap,
        };

        let assetsPath = configJsonPath.split('/');
        assetsPath.pop();
        assetsPath = assetsPath.join('/');
        for (const e of data.assets.spriteSheets) {
            // get the actual atlas from the path
            const atlas = await loadJSON(assetsPath + e.atlasPath); // await works here
            // delete unnecessary properties
            delete atlas.meta;

            let image = new Image();
            image.src = assetsPath + e.imagePath;
            // create an object with each frame of the sprite sheet for faster access
            var frameMap = new Map();
            for (const frame of atlas.frames) {
                frame.frameName = frame.filename;
                delete frame.filename;
                frameMap.set(frame.frameName, {
                    frame: frame.frame,
                    anchor: frame.anchor,
                });
            }
            // add atlas and the image path to the config object
            assets.spriteSheets.set(e.id, {
                ...atlas,
                imagePath: assetsPath + e.imagePath,
                frameMap: frameMap,
                image,
                trimmedRect: e.trimmedRect || null,
            });
        }

        let animSheets = [];
        // do the same for the animations
        for (const e of data.assets.animations) {
            animSheets.push(e.sheetId);
            // get the json obj from the animation config
            const animConfig = await loadJSON(assetsPath + e.animationPath);
            for (let animation of animConfig.anims) {
                // console.log(animation);
                assets.animations.set(animation.state, {
                    key: animation.key,
                    speed: e.speed,
                    sheetId: e.sheetId,
                    frames: [...animation.frames],
                    key: animation.key,
                    type: animation.type,
                    repeat: animation.repeat,
                    frameRate: animation.frameRate,
                    //TODO: duration: animation.frames.length / animation.frameRate,
                });
            }
        }

        levelData.playerConfig = {
            attacks: new Map(),
        };

        for (const attack of data.levelConfig.attacks) {
            levelData.playerConfig.attacks.set(attack.key, {
                animationId: attack.animationId,
            });
        }
        assets.sheets = animSheets;

        return { assets, config: levelData };
    } catch (err) {
        console.error('(function => resolveConfiguration): ', err);
    }
}

// --- helpers ---
function waitForImage(img, { timeoutMs = 15000 } = {}) {
    return new Promise((resolve, reject) => {
        if (img.complete && img.naturalWidth > 0) return resolve();

        let timer = null;
        const cleanup = () => {
            img.removeEventListener('load', onLoad);
            img.removeEventListener('error', onError);
            if (timer) clearTimeout(timer);
        };
        const onLoad = () => {
            cleanup();
            resolve();
        };
        const onError = () => {
            cleanup();
            reject(new Error(`Image failed: ${img.src || '[blob]'}`));
        };

        img.addEventListener('load', onLoad, { once: true });
        img.addEventListener('error', onError, { once: true });

        if (timeoutMs) {
            timer = setTimeout(() => {
                cleanup();
                reject(new Error(`Image load timed out: ${img.src || '[blob]'}`));
            }, timeoutMs);
        }
    });
}

async function waitForSpriteSheets(assets, { timeoutMs = 15000 } = {}) {
    // assumes: assets.spriteSheets is a Map<string, { image: HTMLImageElement, ... }>
    const images = Array.from(assets.spriteSheets.values()).map((s) => s.image);
    await Promise.all(images.map((img) => waitForImage(img, { timeoutMs })));
}

/**
 * Builds a bit mask and trimmed bounding box for an image.
 * The bit mask is an array of bytes where each bit corresponds to a pixel in the image.
 * A set bit (1) indicates that the pixel is visible (alpha >= thresholdAlpha).
 * The trimmed bounding box is the smallest rectangle that encloses all visible pixels.
 * If no visible pixels are found, the trimmed bounds are set to {x: 0, y: 0, w: 0, h: 0}.
 *
 * @param {ImageData} imageData - The image data to process.
 * @param {number} [thresholdAlpha=1] - The minimum alpha value for a pixel to be considered visible.
 * @returns {{mask: Uint8Array, width: number, height: number, trimmedBounds: {x: number, y: number, w: number, h: number}}}
 */
function buildMaskAndTrimmedBounds(imageData, thresholdAlpha = 1) {
    const { data, width, height } = imageData;
    const bitlen = width * height;
    const bytelength = ((bitlen + 7) >> 3) >>> 0;
    const mask = new Uint8Array(bytelength);

    let minX = width,
        minY = height,
        maxX = -1,
        maxY = -1;

    // Walk pixels once
    for (let y = 0, i = 0; y < height; y++) {
        for (let x = 0; x < width; x++, i++) {
            const a = data[(i << 2) + 3]; // RGBA -> alpha at +3
            if (a >= thresholdAlpha) {
                // set bit
                mask[i >> 3] |= 1 << (i & 7);

                // expand bounds
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
        }
    }

    const hasVisible = maxX >= 0;
    const trimmedBounds = hasVisible
        ? { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 }
        : { x: 0, y: 0, w: 0, h: 0 };

    return { mask, width, height, trimmedBounds };
}

// helpers
function maskTest(mask, w, x, y) {
    const i = y * w + x;
    return (mask[i >> 3] >>> (i & 7)) & 1;
}

// axis-aligned mask-vs-mask collision (same scale, same orientation):
function masksOverlap(m1, w1, h1, m2, w2, h2, dx, dy) {
    // test if any visible pixels overlap when m2 is placed at (dx,dy) relative to m1
    const x0 = Math.max(0, dx),
        y0 = Math.max(0, dy);
    const x1 = Math.min(w1, dx + w2),
        y1 = Math.min(h1, dy + h2);
    if (x1 <= x0 || y1 <= y0) return false;

    for (let y = y0; y < y1; y++) {
        const r1 = y * w1,
            r2 = (y - dy) * w2 - dx;
        // walk row in chunks of bits for speed (here: fall back to per-pixel for clarity)
        for (let x = x0; x < x1; x++) {
            const i1 = r1 + x,
                i2 = r2 + x;
            const b1 = (m1[i1 >> 3] >>> (i1 & 7)) & 1;
            if (!b1) continue;
            const b2 = (m2[i2 >> 3] >>> (i2 & 7)) & 1;
            if (b2) return true;
        }
    }
    return false;
}

/****************************************************************************************/
/** JSON file helpers */
/****************************************************************************************/

const printJSON = (obj) => {
    console.log(JSON.stringify(obj, null, 2));
};

const printJSONToFile = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'data.json';
    a.click();
    URL.revokeObjectURL(url);
};

export { loadJSON, waitForSpriteSheets, resolveConfiguration, printJSON, printJSONToFile };
</file>

<file path="src/main.js">
import GameLoop from '@tenoch_code/tlaloopi';
import { GameEngine } from './gameEngine/gameEngine';
import { ComponentTypes, CustomEventEnums, EntityFlags } from './utils/enums';
import { Tabs } from './ui/tabs/tabs';
import { createTabs } from './ui/tabs/createTabs';
import { PlayScene } from './scene/playScene';
import { Entity, EntityManager } from './entityManager/entityManager';
import { BoundingBox, Flags, Interpolation, Sprite } from './components/components';
import { Animation } from './animation/animation';
import { printJSON, printJSONToFile } from './utils/file';

const debug = true;
let ctx = document.getElementById('canvas').getContext('2d');
// let path = '${import.meta.env.BASE_URL}assets/config.json';
let envUrl = import.meta.env.BASE_URL;
console.log(envUrl);
let gameEngine = new GameEngine(envUrl + 'assets/config.json', ctx, debug);

function resizeCanvas(canvas, ctx) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect(); // CSS pixels, fractional

    canvas.width = Math.max(1, Math.round(rect.width * dpr));
    canvas.height = Math.max(1, Math.round(rect.height * dpr));

    // Draw in CSS pixel units; prevents double-scaling.
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

window.addEventListener('resize', (e) => {
    gameEngine.dispatchEvent(new CustomEvent(CustomEventEnums.WINDOW_RESIZED));
    resizeCanvas(canvas, ctx);
});
resizeCanvas(canvas, ctx);

// onload
$(async function () {
    $('#tab-container').draggable();
    await startGame();
    /** @type {Play_Scene} */
    const scene = gameEngine.getCurrentScene();
    $('#print-scene').on('click', () => {
        printSceneJson(gameEngine);
    });
});

async function startGame() {
    let gameLoop = new GameLoop(
        {
            fps: 120,
        },
        gameEngine.fixedUpdate.bind(gameEngine),
        gameEngine.render.bind(gameEngine),
        (timestamp, delta) => {},
        (stats) => {
            // all values in ms
            // stats: { fps, fixedDt, elapsedTime, simulatedTime, leftOverTime, numUpdateSteps}
            $('#fps').text(stats.fps.toFixed(3));
            $('#fixed').text(stats.fixedDt.toFixed(3) / 1000);
            $('#elapsed').text(stats.elapsedTime.toFixed(3) / 1000);
            $('#simTime').text(stats.simulatedTime.toFixed(3) / 1000);
            $('#ticks').text(stats.numUpdateSteps);
            gameEngine.onFrameEnd(stats);
        }
    );

    // Listen for the game stopped event and stop the game loop
    gameEngine.addEventListener(CustomEventEnums.GAME_STOPPED, () => {
        // console.log('the game was stopped');
        gameLoop.stop();
    });

    // Listen for the game started event and start the game loop
    gameEngine.addEventListener(CustomEventEnums.GAME_STARTED, () => {
        gameLoop.start();
    });

    await gameEngine.init();
    gameEngine.dispatchEvent(new Event(CustomEventEnums.GAME_STARTED));
    gameEngine.start();

    await createTabs(new Tabs(document.getElementById('tab-container'), { title: 'Editor' }), gameEngine, {
        entityManager: gameEngine.getSceneEntityManager(),
    });

    const scene = gameEngine.getCurrentScene();
    gameEngine.dispatchEvent(
        new CustomEvent(CustomEventEnums.ENTITIES.UPDATED, {
            detail: {
                count: scene.entityManager.getAllEntities().length,
                entities: scene.entityManager.getAllEntities(),
            },
        })
    );
}

const printSceneJson = (game) => {
    /** @type {Play_Scene} */
    const scene = game.getCurrentScene();
    /** @type {EntityManager} */
    const entityManager = game.getCurrentScene().entityManager;
    /** @type {Entity[]} */
    const entities = entityManager.getAllEntities();
    const entityJson = [];

    for (let i = 0; i < entities.length; i++) {
        /** @type {Entity} */
        const entity = entities[i];
        // Create the entity object
        const obj = {};
        // obj[entities[i].id] = { id: entities[i].id, entityTag: entities[i].tag };
        // console.log(entities[i].id);
        for (const [type, component] of entities[i].getComponents()) {
            const config = componentToConfig(type, component, scene, entity);
            if (config) obj[type] = config;
        }
        entityJson.push(obj);
    }

    console.log(printJSON(entityJson));
    printJSONToFile(entityJson);
};

const componentToConfig = (type, component, scene, entity) => {
    switch (type) {
        case ComponentTypes.CAnimation:
            /** @type {Animation} */
            return component;
        case ComponentTypes.CBoundingBox:
            return { rectangle: component.rectangle, offset: component.offset };
        case ComponentTypes.CCollision:
            return;
        case ComponentTypes.CFlags:
            return component.mask;
        case ComponentTypes.CGravity:
            component.gravity;
        case ComponentTypes.CInput:
            break;
        case ComponentTypes.CInterpolation:
            /** @type {Interpolation} */
            component;
            return component.type;
        case ComponentTypes.CLifespan:
            return component.duration;
        case ComponentTypes.CScore:
            break;
        case ComponentTypes.CSprite:
            return { sheetId: component.sheetId, frame: component.frame };
        case ComponentTypes.CSpriteDimensions:
            return { dimensions: component.dimensions, trimmedRectangle: component.trimmedRect };
        case ComponentTypes.CState:
            return component.state;
        case ComponentTypes.CTraits:
            return component.set;
        case ComponentTypes.CTransform:
            const grid = scene.getEntityTile(entity);
            return {
                position: component.position,
                velocity: component.velocity,
                scale: component.scale,
                angle: component.angle,
                hSpeed: component.hSpeed,
                vSpeed: component.vSpeed,
                grid: { x: grid.x, y: grid.y },
            };
    }
};

// TODO: @Add error handling and logging
</file>

<file path="src/components/components.js">
import { Vector } from 'vecti';
import { Interpolations, ComponentTypes, EntityFlags, PlayerAttacks, EntityStates } from '../utils/enums';
import { Animation } from '../animation/animation';
import { Attack } from '../attack/Attack';

class Component {
    exists = false;
    constructor() {
        // console.log(this);
        this.exists = true;
    }
}

class Interpolation extends Component {
    type = Interpolations.EASEIN_SINE;
    constructor(interpolation) {
        super();
        this.type = interpolation;
    }
}

class SpriteDimensions extends Component {
    dimensions = new Vector(0.0, 0.0);
    trimmedRect = new Vector(0.0, 0.0);
    /**
     * Constructor for SpriteDimensions.
     * @param {Vector} rectangle - The sprite's initial size.
     */
    constructor(dimensions, trimmedRectangle) {
        super();
        this.dimensions = dimensions;
        this.trimmedRect = trimmedRectangle;
    }
}

/**
 * Transform component. Represents the position, velocity, acceleration, and scale of an entity.
 */
class Transform extends Component {
    /**
     * The current position of the entity.
     * @type {Vector}
     */
    position_ = new Vector(0.0, 0.0);

    /**
     * The current velocity of the entity.
     * @type {Vector}
     */
    velocity = new Vector(0.0, 0.0);

    /**
     * The current acceleration of the entity.
     * @type {Vector}
     */
    acceleration = new Vector(0.0, 0.0);

    /**
     * The previous position of the entity.
     * @type {Vector}
     */
    prevPos_ = new Vector(0.0, 0.0);

    /**
     * The scale of the entity.
     * @type {Vector}
     */
    scale = new Vector(1.0, 1.0);

    /**
     * The angle of the entity in radians.
     * @type {number}
     */
    angle = 0.0;

    /**
     * The horizontal speed of the entity.
     * @type {number}
     */
    hSpeed = 0;

    /**
     * The vertical speed of the entity.
     * @type {number}
     */
    vSpeed = 0;

    /**
     * Constructor for Transform.
     * @param {Vector} position - The initial position of the component.
     * @param {Vector} velocity - The initial velocity of the component.
     * @param {Vector} scale - The initial scale of the component.
     * @param {number} angle - The initial angle of the component.
     * @param {number} hSpeed - The initial horizontal speed of the component.
     * @param {number} vSpeed - The initial vertical speed of the component.
     */
    constructor(position, velocity, scale, angle, hSpeed, vSpeed) {
        super();

        this.position_ = position;
        this.prevPos_ = position;
        this.velocity = velocity;
        this.scale = scale;
        this.angle = angle;
        this.hSpeed = hSpeed;
        this.vSpeed = vSpeed;
    }

    /**
     * Gets the current position of the entity.
     * @return {Vector} The current position of the entity.
     */
    get position() {
        return this.position_;
    }

    /**
     * Gets the previous position of the entity.
     * @return {Vector} The previous position of the entity.
     */
    get prevPos() {
        return this.prevPos_;
    }

    /**
     * Sets the current position of the entity.
     * @param {Vector} position - The new position of the entity.
     */
    set position(position) {
        this.prevPos_ = this.position_;
        this.position_ = position;
    }
}
class Lifespan extends Component {
    duration = 0.0;
    frameCreated = 0;

    constructor(duration, frame) {
        super();

        this.duration = duration;
        this.frameCreated = frame;
    }
}

class Attacks extends Component {
    /**
     * @type {PlayerAttacks}
     */
    selected;
    /**
     * @type {Attack}
     */
    #attacksMap = new Map();

    /**
     *
     * @param {PlayerAttacks} initial The attack we are initializing the component with.
     */
    constructor(initial) {
        super();
        this.selected = initial;
    }

    /**
     *
     * @param {Attack} attack The attack that we are adding to this entity.
     */
    addAttack(attack) {
        this.#attacksMap.set(attack.name, attack);
    }

    /**
     *
     * @returns {Attack} The currently selected attack.
     */
    getSelectedAttack() {
        return this.#attacksMap.get(this.selected);
    }

    /**
     *
     * @param {PlayerAttacks} attack
     * @returns
     */
    setAttack(attack) {
        if (this.#attacksMap.has(attack)) {
            return undefined;
        }

        return this.#attacksMap.get(attack);
    }
}

/**
 * ! TODO: unused
 * */
class Input extends Component {
    up = false;
    down = false;
    left = false;
    right = false;
    attack = false;
    isStart = false;
    isEnd = false;
}

class Flags extends Component {
    /** @type {number} - The current mask value. */
    mask;

    /**
     * Constructor for CFlags.
     * @param {number} [mask=0] - The initial mask value.
     */
    constructor(mask = 0) {
        super();
        this.mask = mask;
    }

    /**
     * Adds a flag to the current mask.
     * @param {EntityFlags} flag - The flag to add.
     * @returns {Flags} - This object.
     */
    add(flag) {
        this.mask |= flag;
        return this;
    }

    /**
     * Removes a flag from the current mask.
     * @param {EntityFlags} flag - The flag to remove.
     * @returns {Flags} - This object.
     */
    remove(flag) {
        this.mask &= ~flag;
        return this;
    }

    /**
     * Toggles a flag in the current mask.
     * If the flag is present in the mask, it will be removed. If it is not present, it will be added.
     * @param {EntityFlags} flag - The flag to toggle.
     * @returns {Flags} - This object.
     */
    toggle(flag) {
        this.mask ^= flag;
        return this;
    }

    /**
     * Checks if a flag is present in the current mask.
     * @param {EntityFlags} flag - The flag to check.
     * @returns {boolean} - True if the flag is present, false otherwise.
     */
    has(flag) {
        return (this.mask & flag) !== 0;
    }
}

class Traits extends Component {
    /**
     * Constructs a new Traits object.
     * @param {Array<string>} [initial=[]] - The initial traits to add to the set.
     */
    constructor(initial = []) {
        super();
        this.set = new Set(initial);
    }

    /**
     * Adds a trait to the set.
     * @param {string} t - The trait to add.
     * @returns {Traits} - This object.
     */
    add(t) {
        this.set.add(t);
        return this;
    }

    /**
     * Removes a trait from the set.
     * @param {string} t - The trait to remove.
     * @returns {Traits} - This object.
     */
    remove(t) {
        this.set.delete(t);
        return this;
    }

    /**
     * Checks if the given trait is present in the set.
     * @param {string} t - The trait to check.
     * @returns {boolean} - True if the trait is present, false otherwise.
     */
    has(t) {
        return this.set.has(t);
    }

    /**
     * Returns a JSON representation of the Traits object.
     *
     * @returns {Array<string>} - An array of strings, each representing a trait in the set.
     */
    toJSON() {
        return [...this.set];
    }
}

class BoundingBox extends Component {
    /**
     * Constructor for BoundingBox.
     * @param {Vector} rectangle - The bounding box's initial size.
     */
    rectangle = new Vector(0, 0);

    /**
     * Constructor for BoundingBox.
     * @param {Vector} rectangle - The bounding box's initial size.
     */
    halfSize = new Vector(0, 0);

    /**
     * Constructor for BoundingBox.
     * @param {Vector} rectangle - The bounding box's initial size.
     */
    offset = new Vector(0, 0);

    /**
     * Constructor for BoundingBox.
     * @param {Vector} rectangle - The bounding box's initial size.
     */
    topLeft = null;
    position = null;
    size_ = null;

    /**
     *
     * @param {Vector} rectangle The rectangle dimensions of the bounding box
     * @param {Vector} offset The offset of the bounding box with respect to the sprite's center
     */
    constructor(rectangle, offset) {
        super();
        this.rectangle = rectangle;
        this.offset = offset;
        this.halfSize = this.rectangle.divide(2);
    }

    get size() {
        return this.size_ || this.rectangle;
    }

    set size(size) {
        this.rectangle = size;
        this.halfSize = size.divide(2);
        this.size_ = size;
    }
}

class AnimationStackEntry {
    /** @type {EntityStates} */
    resumeState = null;
    /** @type {Animation} */
    animation;

    /**
     *
     * @param {Animation} animation The animation clip
     * @param {EntityStates} resumeState Metadata used to set state after a non-looping animation ends.
     */
    constructor(animation, resumeState = null) {
        this.animation = animation;
        this.resumeState = resumeState;

        if (!animation.repeats && resumeState == null)
            throw new Error('non looping animations should include a resume state.');
    }
}

class AnimationContainer extends Component {
    /** @type {AnimationStackEntry[]} */
    animationStack = new Array();
    animationPool = new Map();

    /**
     *
     * @param {Animation} animation
     * @param {boolean} repeat
     */
    constructor() {
        super();
    }

    /**
     *
     * @param {Animation} animation The next animation we want to play.
     * @returns {Animation}
     */
    pushAnimation(animation, resumeState = null) {
        animation.reset();
        this.animationStack.push(new AnimationStackEntry(animation, resumeState));
        return animation;
    }

    /**
     *
     * @returns {Animation} The animation at the top of the stack.
     */
    popAnimation() {
        return this.animationStack.pop();
    }

    peekEntry() {
        return this.animationStack[this.animationStack.length - 1];
    }

    /**
     * Returns, without removing, the animation currently at the top of the animation stack.
     *
     * If the stack is empty this returns undefined.
     *
     * @returns {Animation|undefined} The animation at the top of the stack, or undefined if the stack is empty.
     */
    peekAnimation() {
        return this.animationStack[this.animationStack.length - 1].animation ?? null;
    }
}

class Gravity extends Component {
    /** @type {Vector} */
    gravity = null;
    isGrounded = false;

    // This variable holds the amount of time the player has been in the air in milliseconds
    timeInAir = 0;

    timeBeforeFalling = 0;

    /**
     *
     * @param {Vector} gravity
     */
    constructor(gravity) {
        super();

        this.gravity = gravity;
    }
}

class State extends Component {
    /**
     * The current state of the player
     *
     * @type {EntityStates}
     *
     */
    #current_ = 'null';
    previous_ = 'null';

    constructor(state) {
        super();
        this.#current_ = state;
        this.previous_ = state;
    }

    /**
     * Set the current state of the player.
     * This will also set the previous state to the current state.
     * @param {EntityStates} state - The new state of the player.
     */
    set current(state) {
        this.previous_ = this.#current_;
        this.#current_ = state;
    }

    get current() {
        return this.#current_;
    }

    get previous() {
        return this.previous_;
    }
}

class Sprite extends Component {
    sheetId;
    frame;
    constructor(sheetId, frame) {
        super();
        this.sheetId = sheetId;
        this.frame = frame;
    }
}

/**
 * Overlap information between two entities, using center-based AABBs.
 *
 * Coordinates & sizes:
 * - Positions are **centers** in world space.
 * - `ox` / `oy` are **non-negative penetration magnitudes** along X/Y.
 * - `dx` / `dy` are **signed center deltas**: (A.position - B.position).
 * - `mtv` is the **signed minimum translation vector** to ADD to A to separate it from B,
 *   chosen along the **shallow axis** (`axis`).
 *
 * When `overlapping` is false:
 * - `ox` and `oy` are 0,
 * - `mtv` is (0, 0),
 * - `axis` is `null`.
 *
 * @typedef {Object} CollisionData
 * @property {boolean} overlapping - True if A and B overlap (i.e., `ox > 0 && oy > 0`).
 * @property {number} ox - Penetration magnitude along X (â‰¥ 0).
 * @property {number} oy - Penetration magnitude along Y (â‰¥ 0).
 * @property {number} dx - Signed center delta X: `A.x - B.x`.
 * @property {number} dy - Signed center delta Y: `A.y - B.y`.
 * @property {'x'|'y'|null} axis - Shallow axis of penetration; `'x'`, `'y'`, or `null` if not overlapping.
 * @property {Vector} mtv - Signed vector to add to **A** to minimally separate from **B`.
 * @property {Entity} other - The other entity that was used in the collision test.
 */

class Collision extends Component {
    /** @type {CollisionData} */
    prevOverlap = {};

    constructor() {
        super();
    }
}

/**
 * Creates a new component of the given type.
 *
 * @param {string} componentType The type of component to create. This should be one of the values from the ComponentTypes enum.
 * @param {...*} args The arguments to pass to the component's constructor.
 *
 *
 * @returns {Component} The newly created component.
 *
 * @throws {Error} If the component type is invalid.
 *
 * @example
 * const transform = createComponent(ComponentTypes.CTransform, new Vector(0, 0), new Vector(0, 0), new Vector(1, 1), 0);
 * console.log(transform);
 *
 *
 */
const createComponent = (componentType, ...args) => {
    switch (componentType) {
        case ComponentTypes.CAttacks:
            return new Attacks(...args);
        case ComponentTypes.CAnimation:
            return new AnimationContainer(...args);
        case ComponentTypes.CBoundingBox:
            return new BoundingBox(...args);
        case ComponentTypes.CGravity:
            return new Gravity(...args);
        case ComponentTypes.CInput:
            return new Input();
        case ComponentTypes.CInterpolation:
            return new Interpolation(...args);
        case ComponentTypes.CLifespan:
            return new Lifespan(...args);
        case ComponentTypes.CState:
            return new State(...args);
        case ComponentTypes.CTransform:
            return new Transform(...args);
        case ComponentTypes.CSpriteDimensions:
            return new SpriteDimensions(...args);
        case ComponentTypes.CSprite:
            return new Sprite(...args);
        case ComponentTypes.CFlags:
            return new Flags(...args);
        case ComponentTypes.CTraits:
            return new Traits(...args);
        case ComponentTypes.CCollision:
            return new Collision(...args);
    }
};

export {
    createComponent,
    Attacks,
    AnimationContainer,
    AnimationStackEntry,
    BoundingBox,
    Gravity,
    Input,
    Interpolation,
    Lifespan,
    State,
    Transform,
    SpriteDimensions,
    Sprite,
    Flags,
    Traits,
    Collision,
    Component,
};
</file>

<file path="src/utils/userInput.js">
import { ActionEnums, KeyCodes } from './enums';
import { Action } from '../action/action';
import { GameEngine } from '../gameEngine/gameEngine';
import { CustomEventEnums } from './enums';
import { Scene } from '../scene/scene';

class InputHandler extends EventTarget {
    /** @type {GameEngine} */
    #game;

    /** @type {Map<KeyCodes, boolean>} */
    #keysPressed = new Map();

    /**
     * Initializes a new InputHandler instance.
     *
     * @param {GameEngine} game - The GameEngine instance to associate with this InputHandler.
     * The game should extend EventTarget.
     */
    constructor(game) {
        super();

        // game should extend EventTarget
        this.#game = game;
        this.initUserInput();
    }

    /**
     * Checks if a key is currently pressed.
     *
     * @param {KeyCodes} key - The key to check of type enum (KeyCodes).
     * @returns {boolean} true if the key is currently pressed, false otherwise.
     */
    isKeyPressed(key) {
        return !!this.#keysPressed.get(key);
    }

    /**
     * Initializes the user input handlers.
     *
     * This method adds event listeners for the following events:
     *   - keydown: Dispatches a CustomEvent with type ACTION_START and detail { key, repeat }.
     *   - keyup: Dispatches a CustomEvent with type ACTION_END and detail { key, repeat }.
     *   - pointerdown: Dispatches a CustomEvent with type POINTER_DOWN and detail { x, y }.
     *   - pointerup: Dispatches a CustomEvent with type POINTER_UP and detail { x, y }.
     *   - pointermove: Dispatches a CustomEvent with type POINTER_MOVE and detail { x, y }.
     *
     * Note that the event listeners are added to the window and a canvas element.
     * The canvas element is expected to be the main game canvas.
     */
    initUserInput() {
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas');

        window.addEventListener('keydown', (e) => {
            // e.preventDefault();
            this.#keysPressed.set(e.key, true);

            this.#game.dispatchEvent(
                new CustomEvent(CustomEventEnums.ACTION_START, { detail: { key: e.key, repeat: e.repeat } })
            );
        });

        window.addEventListener('keyup', (e) => {
            // e.preventDefault();
            this.#keysPressed.delete(e.key);

            this.#game.dispatchEvent(
                new CustomEvent(CustomEventEnums.ACTION_END, { detail: { key: e.key, repeat: e.repeat } })
            );
        });

        // // src/utils/userInput.js
        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            const { x, y } = this.#getMouseInCanvas(e, canvas);

            this.#game.dispatchEvent(new CustomEvent(CustomEventEnums.POINTER_DOWN, { detail: { x, y } }));
        });

        canvas.addEventListener('pointerup', (e) => {
            e.preventDefault();
            const { x, y } = this.#getMouseInCanvas(e, canvas);

            this.#game.dispatchEvent(new CustomEvent(CustomEventEnums.POINTER_UP, { detail: { x, y } }));
        });

        canvas.addEventListener('pointermove', (e) => {
            e.preventDefault();
            const { x, y } = this.#getMouseInCanvas(e, canvas);

            this.#game.dispatchEvent(new CustomEvent(CustomEventEnums.POINTER_MOVE, { detail: { x, y } }));
        });
    }

    /**
     * Gets the mouse coordinates relative to the canvas element. The coordinates
     * are calculated from the clientX and clientY coordinates of the event object,
     * and are scaled to the size of the canvas element's backing buffer.
     *
     * @param {MouseEvent} e - The mouse event.
     * @param {HTMLCanvasElement} canvas - The canvas element.
     * @returns {Object} - An object with two properties, x and y, which are the
     *     coordinates of the mouse relative to the canvas element.
     */
    #getMouseInCanvas(e, canvas) {
        const rect = canvas.getBoundingClientRect(); // CSS box (includes border)
        const style = getComputedStyle(canvas);

        const padL = parseFloat(style.paddingLeft) || 0;
        const padT = parseFloat(style.paddingTop) || 0;
        const padR = parseFloat(style.paddingRight) || 0;
        const padB = parseFloat(style.paddingBottom) || 0;

        const bL = parseFloat(style.borderLeftWidth) || 0;
        const bT = parseFloat(style.borderTopWidth) || 0;
        const bR = parseFloat(style.borderRightWidth) || 0;
        const bB = parseFloat(style.borderBottomWidth) || 0;

        // Mouse in CSS pixels, relative to the content box
        const xCss = e.clientX - rect.left - bL - padL;
        const yCss = e.clientY - rect.top - bT - padT;

        // // Content-box size in CSS pixels
        // const contentW = rect.width - (padL + padR + bL + bR);
        // const contentH = rect.height - (padT + padB + bT + bB);

        // // Scale to the backing buffer
        // const scaleX = canvas.width / contentW;
        // const scaleY = canvas.height / contentH;

        // return { x: xCss * scaleX, y: yCss * scaleY };
        return { x: xCss, y: yCss };
    }

    // function addAction(e, type, scene) {
    //     // If the current scene does not contain the key as an action
    //     if (!scene.getActionMap().get(e.key)) return;
    //     scene.doAction(scene.getActionMap().get(e.key), type);
    // }
}

export default InputHandler;
</file>

<file path="src/gameEngine/gameEngine.js">
import { resolveConfiguration, waitForSpriteSheets } from '../utils/file';
import {
    ActionKeys,
    ActionLifeCycle,
    CustomEventEnums,
    ScalePolicies,
    EntityTypes,
    KeyCodes,
    EntityFlags,
    TabsEnum,
    SceneTags,
    EntityTraits,
} from '../utils/enums';
import { PlayScene } from '../scene/playScene';
import { Scene } from '../scene/scene';
import { Vector } from 'vecti';
import InputHandler from '../utils/userInput';
import { Action } from '../action/action';
import { printSpriteCacheStats, SpriteCacheGPU } from '../utils/spriteCacheGPU';
import { getScaledSpriteLayout, getScaledSpriteSize } from '../utils/sprite';

class GameEngine extends EventTarget {
    /**
     * Map of all scenes in the game
     *
     * @type {Map<string, PlayScene>}
     */
    #sceneMap = new Map();
    // #assets = new Assets();

    /**
     * The current scene that the game is on
     * @type {string}
     */
    #currentScene = '';
    #simulationSpeed = 1;
    #isRunning = true;
    #DEBUG;

    /**
     * The canvas context
     * @type {CanvasRenderingContext2D}
     */
    #canvasCTX;

    /**
     * The assets
     */
    #assets;
    #configPath;
    updates = 0;
    renders = 0;
    spriteCache = null;
    #pointerCoords = new Vector(0, 0);
    #frameCount = 0;

    /**
     * Sprite selection
     * {
     * details
     * }
     */
    #spriteSelected = null;
    #input;

    levelConfig;

    /**
     * Creates a new GameEngine instance
     * @param {string} path - the path to the game configuration file
     * @param {CanvasRenderingContext2D} ctx - the canvas context to render the game on
     * @param {number} fps - the target frames per second for the game (default: 60)
     */
    constructor(path, ctx, debug = false) {
        super();

        this.#configPath = path;
        this.#canvasCTX = ctx;
        this.#DEBUG = debug;
        this.#input = new InputHandler(this);
    }

    async init() {
        this.#canvasCTX.imageSmoothingEnabled = false;
        const { assets, config } = await resolveConfiguration(this.#configPath);
        this.#assets = assets;
        this.levelConfig = config;
        this.spriteCache = new SpriteCacheGPU(128 * 1024 * 1024);

        try {
            // Wait for all images to load before proceeding
            await waitForSpriteSheets(this.#assets);

            // Prewarm the sprite cache
            for (let sheet of this.#assets.spriteSheets.values()) {
                let sheetImage = sheet.image;
                let frames = sheet.frames.map((frame) => {
                    const r = frame.frame;
                    return { sx: r.x, sy: r.y, sw: r.w, sh: r.h };
                });

                // Prewarm both orientations
                await this.spriteCache.prewarm(sheetImage, frames, 'none');
                await this.spriteCache.prewarm(sheetImage, frames, 'flipX');
            }

            console.groupCollapsed('*****************************************************\nassets and config loaded');
            console.log('');
            console.info('assets and config loaded');
            console.info(this.levelConfig);
            console.info(this.#assets);
            console.groupEnd();
        } catch (err) {
            console.error(err);
            this.stop();
            this.dispatchEvent(new CustomEvent(CustomEventEnums.GAME_STOPPED));
        }

        const playScene = new PlayScene(this);
        this.changeScene(SceneTags.Play, playScene);
        // console.log('sprite cache prewarmed', this.spriteCache.map, this.spriteCache.inflight);
        printSpriteCacheStats(this.spriteCache);

        this.#addEventListeners();

        // console.log(playScene.entityManager.getAllEntities());
        this.dispatchEvent(
            new CustomEvent(CustomEventEnums.ENTITIES.UPDATED, {
                detail: {
                    count: playScene.entityManager.getAllEntities().length,
                    entities: playScene.entityManager.getAllEntities(),
                },
            })
        );
    }

    changeScene(
        sceneName,
        scene, // A reference to the scene
        endCurrentScene = false
    ) {
        if (endCurrentScene) {
            this.#sceneMap.get(this.#currentScene).hasEnded = true;
        }

        this.#currentScene = sceneName;
        if (!this.#sceneMap.has(sceneName)) {
            this.#sceneMap.set(sceneName, scene);
        } else {
            this.#sceneMap.set(sceneName, scene);
        }

        // Add an event listener to the scene to listen for the game stopped event
        this.#sceneMap.get(this.#currentScene).addEventListener(CustomEventEnums.GAME_STOPPED, () => {
            this.setPaused(true);
        });
    }

    fixedUpdate(dt) {
        // If the game was turned off stop the loop
        // TODO: FOLLOW-UP handle reset and game end better
        if (!this.isRunning()) return;

        if (this.#input.isKeyPressed(KeyCodes.shift) && this.#input.isKeyPressed(KeyCodes.backspace))
            this.#spriteSelected = null;

        // call the update for the current scene
        // TODO: uncomment once we have an inherited Scene
        this.#sceneMap.get(this.#currentScene).fixedUpdate(dt);
    }

    onFrameEnd({ fps, fixedDt, elapsedTime, simulatedTime, leftOverTime, numUpdateSteps }) {
        // stats: { fps, fixedDt, elapsedTime, simulatedTime, leftOverTime, numUpdateSteps}
        this.#sceneMap.get(this.#currentScene).onFrameEnd(elapsedTime, numUpdateSteps);
    }

    render(alpha) {
        if (!this.isRunning()) return;
        // Clear the canvas
        this.#canvasCTX.clearRect(0, 0, this.#canvasCTX.canvas.width, this.#canvasCTX.canvas.height);

        // Call the scene's render method
        this.#sceneMap.get(this.#currentScene).sRender(alpha);
    }

    quit() {
        // TODO: quit the game
        this.#isRunning = false;
    }

    stop() {
        // TODO: FOLLOW-UP pause or stop the game
        this.#isRunning = false;
    }

    start() {
        this.#isRunning = true;
    }

    isRunning() {
        return this.#isRunning;
    }
    getAssets() {
        return this.#assets;
    }

    /**
     * Gets the current scene that the game is on.
     * @returns {Scene} The current scene.
     */
    getCurrentScene() {
        return this.#sceneMap.get(this.#currentScene);
    }

    drawLine(point1, point2) {
        this.#canvasCTX.beginPath();
        this.#canvasCTX.moveTo(point1.x, point1.y);
        this.#canvasCTX.lineTo(point2.x, point2.y);
        this.#canvasCTX.stroke();
    }

    /**
     * Draw a sprite from a sprite sheet onto the game canvas.
     *
     * @param {string} sheetId - The id of the sprite sheet.
     * @param {string} spriteName - The name of the sprite to draw.
     * @param {Vector} pos - The position of the top left of the
     *     sprite in the canvas.
     * @param {Vector} size - The size of the sprite in the canvas.
     */
    async drawSprite(sheetId, spriteName, pos, scale) {
        const sheet = this.#assets.spriteSheets.get(sheetId);
        const img = sheet.image;
        const sprite = sheet.frameMap.get(spriteName);
        const frame = sprite.frame;
        const tr = new Vector(frame.w, frame.h);
        if (sheet.trimmedRect) {
            tr.x = sheet.trimmedRect.width;
            tr.y = sheet.trimmedRect.height;
        }

        // const sx = Math.abs(scale.x);
        // let scaledBox = getScaledSpriteSize(tr, scale, ScalePolicies.UNIFORM_Y, null);
        let { drawSize, logicalSizeScaled, trimmedTopLeft, trimmedCenter, kx, ky } = getScaledSpriteLayout(
            tr,
            new Vector(frame.w, frame.h),
            scale,
            ScalePolicies.UNIFORM_Y,
            pos,
            null
        );

        const bmp = await this.spriteCache.get(
            img,
            frame.x,
            frame.y,
            frame.w,
            frame.h,
            scale.x >= 0 ? 'none' : 'flipX'
        );

        this.#canvasCTX.drawImage(bmp, trimmedCenter.x, trimmedCenter.y, logicalSizeScaled.x, logicalSizeScaled.y);
    }

    /**
     * Draws a string onto the game canvas.
     *
     * @param {string} text - The string to draw.
     * @param {Vector} pos - The position of the top left of the
     *     text in the canvas.
     * @param {string} color - The color of the text.
     * @param {string} font - The css font string to use.
     */
    drawString(text, pos, color, font) {
        this.#canvasCTX.fillStyle = color;
        this.#canvasCTX.font = font;
        this.#canvasCTX.fillText(text, pos.x, pos.y);
    }

    loadAllImages() {
        this.#assets.textures.forEach((texture) => {});
    }

    getAnimations() {
        return this.#assets.animations;
    }

    getAnimation(animationName) {
        return this.#assets.animations.get(animationName);
    }

    getSpriteDimensions(sheetId) {
        return this.#assets.spriteSheets.get(sheetId).frames[0].frame;
    }

    /**
     * Returns the sprite data for a given sprite sheet and frame id.
     *
     * @param {string} sheetId - The id of the sprite sheet.
     * @param {string} frameId - The id of the frame.
     * @return {{w: number, h: number, x: number, y: number}} - The width, height, and
     *     position of the frame in the sprite sheet.
     */
    getSpriteData(sheetId, frameId) {
        // frame={
        // "w": 192,
        // "h": 168,
        // "x": 0,
        // "y": 0
        // }
        return this.#assets.spriteSheets.get(sheetId).frameMap.get(frameId).frame;
    }

    getImage(sheetId) {
        // this.#assets.
        return this.#assets.spriteSheets.get(sheetId).image;
    }

    /**
     * Draws a circle on the canvas.
     *
     * @param {Vector} pos - The center of the circle.
     * @param {number} radius - The radius of the circle.
     */
    drawCircle(pos, radius) {
        this.#canvasCTX.beginPath();
        this.#canvasCTX.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
        this.#canvasCTX.stroke();
        this.#canvasCTX.closePath();
    }

    drawCircleFilled(pos, radius, color) {
        this.#canvasCTX.beginPath();
        this.#canvasCTX.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
        this.#canvasCTX.fillStyle = color;
        this.#canvasCTX.fill();
        this.#canvasCTX.closePath();
    }

    /**
     * Draws a rectangle on the canvas.
     *
     * If `fillColor` is given, the rectangle is filled with that color. Otherwise,
     * the rectangle is only stroked with the given `color`.
     *
     * @param {Vector} pos - The top left of the rectangle.
     * @param {Vector} size - The size of the rectangle: size.x => width and size.y  => height
     * @param {string} [color='#000000'] - The color of the border.
     * @param {string} [fillColor] - The color to fill the rectangle with.
     */
    drawRect(pos, size, color = '#000000', fillColor = null) {
        if (fillColor) {
            this.#canvasCTX.fillStyle = fillColor;
        }

        if (!fillColor) {
            this.#canvasCTX.strokeStyle = color;
            this.#canvasCTX.strokeRect(pos.x, pos.y, size.x, size.y);
        } else {
            this.#canvasCTX.fillRect(pos.x, pos.y, size.x, size.y);
            this.#canvasCTX.strokeRect(pos.x, pos.y, size.x, size.y);
        }
    }

    /*****************************************************************************
     * Getters and Setters
     ******************************************************************************/

    getSceneEntityManager() {
        const scene = this.getCurrentScene();
        return scene.entityManager;
    }

    getImage(sheetId) {
        // this.#assets.
        return this.#assets.spriteSheets.get(sheetId).image;
    }

    /**
     * Gets the trimmed rectangle for a given spriteId.
     * If the spriteId is invalid or the sprite sheet doesn't have a trimmed rectangle,
     * returns null.
     *
     * @param {string} spriteId - The id of the sprite sheet to get the trimmed rectangle for.
     * @returns {{width: number, height: number}} The trimmed rectangle of the sprite sheet, or null if invalid.
     */
    getSpriteTrimmedRect(spriteId) {
        return this.#assets.spriteSheets.get(spriteId).trimmedRect || null;
    }

    /**
     * The width of the canvas.
     *
     * @returns {number} The width of the canvas.
     */
    get width() {
        return this.#canvasCTX.canvas.width;
    }

    getTest() {
        console.log('testing get ');
    }

    /**
     * The height of the canvas.
     *
     * @returns {number} The height of the canvas.
     */

    get height() {
        return this.#canvasCTX.canvas.height;
    }

    get assets() {
        return this.#assets;
    }

    /** Device pixel ratio in effect for the main ctx */
    get dpr() {
        const m = this.#canvasCTX.getTransform?.();
        return m && m.a ? m.a : window.devicePixelRatio || 1;
    }
    /**
     * The width of the canvas in logical (CSS) units.
     *
     * This is the width of the canvas, divided by the device pixel ratio.
     *
     * @returns {number} The width of the canvas in logical units.
     */
    get logicalWidth() {
        return this.width / this.dpr;
    }

    get logicalHeight() {
        return this.height / this.dpr;
    }

    /**
     * The canvas context (2D drawing context) for the game canvas.
     *
     * @returns {CanvasRenderingContext2D} The canvas context.
     */
    get ctx() {
        return this.#canvasCTX;
    }

    /**
     * The current x-coordinate of the pointer in the game canvas.
     *
     * @returns {number} The x-coordinate of the pointer.
     */
    get pointerX() {
        return this.#pointerCoords.x;
    }

    /**
     * The current y-coordinate of the pointer in the game canvas.
     *
     * @returns {number} The y-coordinate of the pointer.
     */
    get pointerY() {
        return this.#pointerCoords.y;
    }

    /**
     * Gets the current pointer position as a Vector.
     *
     * @returns {Vector} The current pointer position.
     */
    get pointerPosition() {
        return this.#pointerCoords;
    }

    /*----------------------------------------------------------------------------
     * helper functions
     *-----------------------------------------------------------------------------*/

    #addEventListeners() {
        /********************   Window Events          *******************/
        this.addEventListener(CustomEventEnums.WINDOW_RESIZED, (e) => {
            // resizeCanvas(this.#canvasCTX.canvas, this.#canvasCTX);
        });

        /********************   Keyboard/button Events *******************/
        this.addEventListener(CustomEventEnums.ACTION_START, (e) => {
            if (e.detail.repeat) return;
            if (e.detail.key == ActionKeys.p) {
                if (this.isRunning()) {
                    this.stop();
                    this.dispatchEvent(new CustomEvent(CustomEventEnums.GAME_STOPPED));
                    return;
                }
                if (!this.isRunning()) {
                    this.start();
                    this.dispatchEvent(new CustomEvent(CustomEventEnums.GAME_STARTED));
                    return;
                }
                return;
            }

            if (this.#DEBUG && e.detail.key == ActionKeys.escape && this.#spriteSelected) {
                this.#spriteSelected = null;
            }

            let scene = this.#sceneMap.get(this.#currentScene);
            if (!scene.actionMap.has(e.detail.key)) return;
            let action = new Action(scene.actionMap.get(e.detail.key), ActionLifeCycle.START);
            scene.actionEnqueue(action);
        });

        this.addEventListener(CustomEventEnums.ACTION_END, (e) => {
            let scene = this.#sceneMap.get(this.#currentScene);
            if (!scene.actionMap.has(e.detail.key)) return;
            let action = new Action(scene.actionMap.get(e.detail.key), ActionLifeCycle.END);
            scene.actionEnqueue(action);
        });

        /********************   Pointer Events *******************/

        this.addEventListener(CustomEventEnums.POINTER_MOVE, (e) => {
            // console.log(e.detail);
            this.#pointerCoords = new Vector(e.detail.x, e.detail.y);
            let scene = this.#sceneMap.get(this.#currentScene);
            if (!scene.actionMap.has(ActionKeys.pointerMove)) return;

            let action = new Action(scene.actionMap.get(ActionKeys.pointerMove), ActionLifeCycle.END);
            action.payload = this.#pointerCoords;
            scene.sDoActionImm(action);
        });

        this.addEventListener(CustomEventEnums.POINTER_DOWN, (e) => {
            let scene = this.#sceneMap.get(this.#currentScene);
            if (!scene.actionMap.has(ActionKeys.pointerDown)) return;

            let action = new Action(scene.actionMap.get(ActionKeys.pointerDown), ActionLifeCycle.START);
            action.payload = new Vector(e.detail.x, e.detail.y);
            scene.sDoActionImm(action);

            // **** event:sprite select
            if (this.#DEBUG && this.#spriteSelected) {
                console.log('placing sprite');
                console.info(this.#spriteSelected);
                scene.placeSpriteEntityGrid(
                    EntityTypes.GROUND,
                    e.detail.x,
                    e.detail.y,
                    [EntityFlags.STATIC, EntityFlags.COLLIDES],
                    [EntityTraits.STATIC, EntityTraits.COLLIDES],
                    this.#spriteSelected.sheetId,
                    this.#spriteSelected.frame
                );

                // if (!this.#input.isKeyPressed(KeyCodes.alt)) this.#spriteSelected = null;
            }
        });

        this.addEventListener(CustomEventEnums.POINTER_UP, (e) => {
            let scene = this.#sceneMap.get(this.#currentScene);
            if (!scene.actionMap.has(ActionKeys.pointerUp)) return;

            let action = new Action(scene.actionMap.get(ActionKeys.pointerUp), ActionLifeCycle.START);
            scene.sDoActionImm(action);
        });

        /******************** Debugging   Sprite Events ******************* */
        if (this.#DEBUG) {
            this.addEventListener(CustomEventEnums.SPRITE.SELECT, (e) => {
                this.#spriteSelected = {
                    sheetId: e.detail.sheetId,
                    frame: e.detail.frame.frameName,
                };
            });

            this.addEventListener(CustomEventEnums.SPRITE.CLEAR_SELECTION, () => {
                this.#spriteSelected = null;
            });

            this.addEventListener(CustomEventEnums.TAB.SELECTED, (e) => {
                // console.log('tab switched', e.detail);
                const scene = this.getCurrentScene();
                if (e.detail.id == TabsEnum.ID.ENTITIES && scene.tag == SceneTags.PLAY) {
                    this.dispatchEvent(
                        new CustomEvent(CustomEventEnums.ENTITIES.UPDATED, {
                            detail: {
                                count: scene.entityManager.getAllEntities().length,
                                entities: scene.entityManager.getAllEntities(),
                            },
                        })
                    );
                }
            });
        }
    }
}

export { GameEngine };
</file>

</files>
